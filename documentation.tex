\documentclass[twoside]{projektInzynierskiMS1}
\usepackage{polski}
\usepackage[dvipsnames]{xcolor}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{array}
\usepackage{ragged2e}
\usepackage{hyperref}
\usepackage{colortbl}
\usepackage{etoolbox} 
\usepackage{enumitem}
\usepackage{caption}
\usepackage{listings}

\captionsetup{hypcap=false}
\pdfstringdefDisableCommands{%
  \def\kern{}%
}

% Custom language definitions and styles for C# and React
\lstdefinelanguage{CSharp}{
  keywords=[1]{abstract, as, base, bool, break, byte, case, catch, char, checked, class, const, continue, decimal, default, delegate, do, double, else, enum, event, explicit, extern, false, finally, fixed, float, for, foreach, goto, if, implicit, in, int, interface, internal, is, lock, long, namespace, new, null, object, operator, out, override, params, private, protected, public, readonly, ref, return, sbyte, sealed, short, sizeof, stackalloc, static, string, struct, switch, this, throw, true, try, typeof, uint, ulong, unchecked, unsafe, ushort, using, virtual, void, volatile, while},
  keywords=[2]{var, dynamic, async, await, Task, ValueTask, yield},
  sensitive=true,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
}

\lstdefinelanguage{JSX}{
  keywords=[1]{const, let, var, function, return, if, else, for, while, do, break, continue, switch, case, default, true, false, null, import, from, export, class, extends, super, this, new, try, catch, finally, throw, async, await},
  keywords=[2]{useState, useEffect, useRef, useContext, useReducer, React, Component, render, StrictMode},
  keywords=[3]{div, span, h1, h2, h3, h4, h5, h6, p, ul, li, button, input, form},
  sensitive=true,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]", % Double quote strings
  morestring=[b]', % Single quote strings
  alsoletter={<>}, % Recognize <> as part of JSX
}

\lstset{
  basicstyle=\ttfamily\small,
  keywordstyle=[1]\color{blue},
  keywordstyle=[2]\color{teal},
  keywordstyle=[3]\color{purple},
  commentstyle=\color{gray},
  stringstyle=\color{red},
  numbers=left,
  numberstyle=\tiny\color{gray},
  stepnumber=1,
  backgroundcolor=\color{lightgray!10},
  breaklines=true,
  showstringspaces=false,
}


\title{Gra sieciowa w środowisku aplikacji webowej - Szachy}

\promotor{dr inż. Zdzisław Sroczyński}
\rodzajProm{PROWADZĄCY PRACĘ}

\specjalnosc{Inżyniera analizy danych}

\autor{Bruno Masłoń}{303220}

\newtheorem{tw}{Twierdzenie}%[subsection]
\newtheorem{twa}{Twierdzenie}%[section]
\newtheorem{dd}{Definicja}%[subsection]

\drugaStrona

\strDrNap{Streszczenie}

\noindent
Projekt to webowa aplikacja do gry w szachy, łącząca strone kliencką, utworzoną z pomocą biblioteki React, z serwerową opartą na .NET Framework. Oferuje rozgrywki online z graczami lub silnikiem szachowym Stockfish, dynamiczne tryby czasowe oraz funkcje społecznościowe, takie jak system znajomości i personalizacja. Aplikacja zapewnia intuicyjny interfejs, płynną rozgrywkę i wysoki komfort użytkowania.

\strDrNap{Słowa kluczowe}

\noindent
Szachy, Gry online, Strona internetowa

\strDrNap{Thesis title}

\noindent
Web game in a web application environment - Chess

\strDrNap{Abstract}

\noindent
The project is a web-based chess application that combines a client side, created with the help of the React library, with a server side based on the .NET Framework. It offers online gameplay with players or the Stockfish chess engine, dynamic time modes and community features such as a friendship system and personalization. The application provides an intuitive interface, smooth gameplay and a high user experience.

\strDrNap{Keywords}

\noindent
Chess, Online Games, Website

\koniecDrugaStrona

\begin{document}

\subsection{\texorpdfstring{Opis projektu}{Opis projektu}}

\noindent
Projekt aplikacji szachowej, dalej nazywany \texttt{BRNChess} to aplikacja webowa, zaprojektowana dla osób zainteresowanych szachami, składająca się z dwóch głównych komponentów: aplikacji internetowej (frontend) oraz aplikacji serwerowej (backend). Strona kliencka została utworzona w oparciu o technologie React oraz Vite, a kod jest pisany w języku TypeScript, co zapewnia wysoką wydajność, czytelność i skalowalność projektu. Backend natomiast opiera się na platformie .NET Framework, co umożliwia szybkie i niezawodne przetwarzanie logiki serwera oraz integrację z różnymi usługami.
\\\\
Aplikacja ma na celu zapewnienie użytkownikom możliwości rozgrywki w jedną z najstarszych i najpopularniejszych gier PvP (ang. Player versus Player - gracz kontra gracz) na świecie, jaką są szachy. Jest to strategiczna gra planszowa dla dwóch graczy, w której każdy kontroluje zestaw figur szachowych, dążąc do zaszachowania króla przeciwnika, czyli postawienia go w sytuacji nieuchronnego schwytania. Zasady współczesnych szachów zostały ukształtowane w Europie pod koniec XV wieku, a ich pełna standaryzacja miała miejsce w XIX wieku. \cite{ChessWiki}
\\\\
Aplikacja \texttt{BRNChess} umożliwia rozgrywkę online z innymi graczami lub zaawansowanym silnikiem Stockfish, zapewniając dynamiczne tryby czasowe dzięki technologii SignalR. Posiada także system znajomości do zarządzania kontaktami i personalizacji gry, co czyni ją platformą społecznościową. Intuicyjny interfejs i płynne rozgrywki w czasie rzeczywistym podkreślają nacisk na wysoką jakość użytkowania, zachęcając graczy do częstego powrotu.

\newpage

\subsection{Główne założenia i cele projektu}

\begin{itemize}
    \item \textbf{Gra online:}\
    Aplikacja oferuje platformę do gry w szachy online, z doborem przeciwników według rankingu. Różne tryby czasowe uatrakcyjniają rozgrywki i dodają dynamiki, a gra w czasie rzeczywistym zwiększa emocje i angażuje graczy.
    
    \item \textbf{Gra offline:}\
    Integracja z silnikiem Stockfish umożliwia grę z komputerem, idealną do ćwiczenia umiejętności bez konieczności szukania przeciwnika. Rozgrywki offline zapewniają wyzwania na każdym poziomie.
    
    \item \textbf{Gra ze znajomymi:}\
    System znajomości pozwala tworzyć listy znajomych i organizować rozgrywki na zaproszenie, eliminując losowy dobór przeciwników. Umożliwia to budowanie społeczności w aplikacji.
    
    \item \textbf{Interfejs użytkownika:}\
    Interfejs jest intuicyjny, estetyczny i prosty w obsłudze, co ułatwia dostęp do funkcji i zwiększa zaangażowanie. Dbałość o szczegóły sprawia, że korzystanie z aplikacji jest przyjemne i wygodne.
    
    \item \textbf{Konto użytkownika:}\
    Każdy użytkownik posiada konto przechowujące dane, historię gier i osiągnięcia, z opcją personalizacji ustawień.
    
    \item \textbf{Bezpieczeństwo danych:}\
    Dane użytkowników, w tym wrażliwe, są zabezpieczone za pomocą nowoczesnych technologii szyfrowania, zapewniając ich prywatność i ochronę.
    
    \item \textbf{Dodatkowe funkcjonalności:}\
    Aplikacja oferuje globalny ranking, rankingi znajomych, analizę historii gier i możliwość dostosowania ustawień, co wzbogaca doświadczenia użytkowników.
    \end{itemize}

\newpage

\section{Stos technologiczny}

\subsection{Aplikacja internetowa (frontend)}

\noindent \textbf{Javascript oraz Typescript}\\
JavaScript to język programowania, używany najczęściej przy tworzeniu stron www, zapewniając ich interaktywność oraz obsługę zdarzeń, walidację formularzy czy budowanie elementów nawigacyjnych. Jednak można także pisać w nim pełnoprawne aplikacje (korzystając z frameworków do budowania aplikacji jak np. React). Javascript może też być wykorzystywany do tworzenia gier w przeglądarkach, a jednym z popularnych frameworków do tego celu jest Phaser. JS-a można używać również po stronie serwera dzięki frameworkowi Node. \cite{JustJoinJS}
\\\\
TypeScript to język programowania utworzony przez Microsoft w 2012 roku. Jego twórcą jest Anders Hejlsberg, znany również jako ojciec języka C\# \cite{WikiAndersHejlsberg}. TypeScript jest nadzbiorem JavaScriptu, co oznacza, że każdy poprawny kod JS jest równocześnie poprawnym kodem TS. W praktyce TypeScript rozszerza możliwości JavaScriptu o opcjonalne statyczne typowanie oraz nowe struktury danych. TS posiada też aktywną społeczność programistów tworzących biblioteki, które ułatwiają pracę programistom poprzez dodawanie typowania do już istniejących projektów, dzięki temu są one przystosowane do pracy z TypeScriptem. \cite{DropticaTypeScript}
\\\\
Głównym celem powstania TypeScriptu było wprowadzenie silniejszego systemu typów do JavaScriptu, które pozwalają na odgórne ustalanie rodzajów zdefiniowanych przez dewelopera zmiennych, aby ułatwić tworzenie dużych, skalowalnych aplikacji. Język ten stał się popularny wśród deweloperów dzięki swojej elastyczności, możliwościom oferowanym przez statyczne typowanie oraz łatwości integracji z istniejącymi projektami JS.
\\\\
W niniejszym projekcie, JavaScript został wybrany jako baza projektu ze względu na znajomość tego języka oraz jego powszechność w budowie aplikacji webowych. Jego wszechstronność i bogaty ekosystem narzędzi oraz bibliotek, takich jak React, czynią go naturalnym wyborem dla projektów tego typu.
\\\\
TypeScript został wybrany przede wszystkim w celu uzyskania lepszej kontroli nad kodem. Dzięki wprowadzeniu statycznego typowania i bardziej rygorystycznej strukturze, TypeScript pozwala na wcześniejsze wykrywanie błędów, co przekłada się na większą stabilność i łatwiejsze utrzymanie aplikacji.
\\\\
Połączenie JavaScriptu i TypeScriptu pozwala skorzystać z najlepszych cech obu technologii – elastyczności i popularności JS oraz dodatkowego bezpieczeństwa i przewidywalności oferowanego przez TS.
\\\\

\noindent \textbf{React oraz Vite}\\
React to biblioteka JavaScript służąca do renderowania interfejsów użytkownika (UI). Interfejs użytkownika składa się z małych jednostek, takich jak przyciski, tekst i obrazy. React pozwala łączyć je w komponenty wielokrotnego użytku, które można zagnieżdżać. Od stron internetowych po aplikacje na telefony, wszystko na ekranie można podzielić na komponenty. Każdy komponent Reacta jest funkcją JavaScript, która może zawierać pewne znaczniki renderowane w przeglądarce. Komponenty Reacta używają rozszerzenia składni o nazwie JSX do reprezentowania tych znaczników. JSX wygląda bardzo podobnie do HTML, jednak jest nieco bardziej rygorystyczny oraz może wyświetlać dynamiczne informacje. \cite{ReactUI}
\\\\
Vite to nowoczesne i wydajne  narzędzie do budowania aplikacji frontend, które ma na celu zapewnienie szybszego i bardziej oszczędnego doświadczenia programistycznego dla nowoczesnych projektów internetowych, utworzony przez twórcę Vue.js - Evana You. Jest on znany ze swojej niewiarygodnej szybkości, dzięki wykorzystaniu natywnych modułów ES dla przyspieszonego hot module replacement (HMR) oraz kompilacji w przeglądarce. Vite.js przełamuje tradycyjne bariery w budowie aplikacji, eliminując konieczność korzystania z bundlerów takich jak Webpack czy Rollup. Jego modularna architektura oraz wsparcie dla wielu ramkowych, w tym Vue czy React, czynią go uniwersalnym i elastycznym narzędziem. \cite{BoringOwlViteJS}
\\\\
React został wybrany ze względu na znajomość tej technologii oraz jej szerokie zastosowanie w tworzeniu aplikacji webowych. Intuicyjność pisania kodu w React, oparta na komponentach wielokrotnego użytku i JSX, sprawia, że praca z tą biblioteką jest wygodna i efektywna. Dodatkowo React oferuje szerokie wsparcie społeczności oraz dostęp do bogatego ekosystemu bibliotek, co ułatwia rozwijanie i utrzymanie projektu.
\\\\
Vite natomiast został wybrany głównie ze względu na swoją szybkość, zarówno podczas początkowego uruchamiania projektu, jak i w trakcie jego rozwoju. Wykorzystanie funkcji hot module replacement znacznie przyspiesza pracę, a minimalistyczna konfiguracja upraszcza proces tworzenia aplikacji. Dodatkowym atutem Vite jest jego elastyczność oraz możliwość łatwego integracji z Reactem, co czyni go idealnym wyborem dla nowoczesnych projektów frontendowych.
\\\\

\noindent \textbf{Sass / SCSS}\\
Sass to preprocessor CSS, który umożliwia programowanie styli w znacznie bardziej efektywny i zorganizowany sposób niż zwykły CSS. Pozwala na definiowanie stałych, zagnieżdżanie reguł CSS, używanie zmiennych, funkcji czy operatorów. Dzięki temu, można wykorzystać Sass do szybszego i łatwiejszego tworzenia stylów strony, a także czytać i zarządzać istniejącym kodem znacznie lepiej. Jest to szczególnie przydatne w przypadku dużych projektów, gdzie style są rozbudowane i trudne do zarządzania. \cite{BoringOwlSass}
\\\\
Sass i SCSS zostały wybrane do projektu ze względu na funkcjonalności, które znacznie rozszerzają możliwości standardowego CSS. Sass pozwala na stosowanie zmiennych, zagnieżdżania reguł, funkcji czy operatorów, co czyni pracę nad stylami bardziej efektywną i zorganizowaną. Dzięki temu stylowanie dużych projektów jest prostsze i bardziej przejrzyste, a zarządzanie kodem staje się łatwiejsze.
\\\\
W projekcie wykorzystywane są pliki .module.scss, które umożliwiają stosowanie lokalnie zdefiniowanych klas CSS. Mechanizm ten działa w ten sposób, że klasy zadeklarowane w tych plikach są mapowane na unikalne nazwy, co zapobiega ich kolizjom i zapewnia lepszą organizację stylów.
\\\\
SCSS został wybrany zamiast gotowych komponentów CSS, aby zapewnić pełną kontrolę nad stylizacją elementów. Pozwala to dostosowywać wygląd aplikacji dokładnie do jej potrzeb, bez ograniczeń narzuconych przez gotowe rozwiązania. Dzięki SCSS możliwe jest tworzenie rozbudowanych, ale zarazem dobrze utrzymywanych arkuszy stylów, które doskonale wspierają rozwój projektu.

\newpage

\subsection{Aplikacja serwerowa (backend)}

\noindent \textbf{C\#}\\
C\# jest nowoczesnym, obiektowym językiem wysokiego poziomu, który został opracowany na zlecenie Microsoft już w latach 1998 - 2001. Pod względem składni porównuje się go często do języków takich, jak Object Pascal, \texttt{C++} i Java. W środowisku programistycznym uznawany jest za prosty, przyjazny i przejrzysty. C\# jest ściśle związany z platformą .NET, która stanowi dla niego framework i środowisko uruchomieniowe zarazem. Przez długi czas ta zależność wskazywana była jako największa wada języka, bowiem ograniczała jego zastosowanie jedynie do systemów Windows. Microsoft rozwiązał ten problem w 2016 roku, publikując .NET Core - kompatybilny również z innymi systemami operacyjnymi. Od tego czasu C\# służy do budowy programów i aplikacji na wszystkie systemy operacyjne. \cite{CSharp}
\\\\
C\# został wybrany do części serwerowej projektu ze względu na jego ścisłą integrację z platformą .NET, która jest niezbędna do realizacji tego projektu. Język ten zapewnia wydajność, elastyczność i bogaty zestaw narzędzi wspierających tworzenie nowoczesnych aplikacji backendowych.
\\\\
Dodatkowo, C\# jest językiem obiektowym i nowoczesnym, co ułatwia projektowanie skalowalnych, dobrze zorganizowanych aplikacji. Jego przyjazna składnia i przejrzystość sprawiają, że tworzenie kodu jest bardziej efektywne, a utrzymanie projektu łatwiejsze. Język ten oferuje także wsparcie dla zaawansowanych funkcji, takich jak zarządzanie pamięcią, asynchroniczność czy bogate możliwości integracji z bazami danych i systemami zewnętrznymi.
\\\\
Platforma .NET, na której opiera się C\#, pozwala na uruchamianie aplikacji na różnych systemach operacyjnych, co zwiększa jej uniwersalność. Dzięki temu C\# nie tylko spełnia wymagania techniczne projektu, ale także umożliwia łatwe rozszerzanie i adaptację aplikacji w przyszłości.
\\\\

\noindent \textbf{.NET Framework}\\
.NET Framework to środowisko wykonywania, które zarządza aplikacjami docelowymi .NET Framework. Składa się ze środowiska uruchomieniowego języka wspólnego, które zapewnia zarządzanie pamięcią i inne usługi systemowe, oraz rozbudowanej biblioteki klas, która umożliwia programistom korzystanie z niezawodnego kodu dla wszystkich głównych obszarów opracowywania aplikacji. \cite{DotNetStart}
\\\\
.NET zostało wybrane do budowy backendu projektu ze względu na jego wszechstronność, wydajność oraz rozbudowane narzędzia, które wspierają tworzenie aplikacji serwerowych. Kluczowym powodem wyboru .NET jest jego solidne wsparcie dla tworzenia aplikacji REST API, co umożliwia łatwą i efektywną komunikację między frontendem a backendem. Dodatkowo, .NET oferuje Entity Framework Core, który stanowi doskonałe narzędzie do pracy z bazą danych. Dzięki EF Core możliwe jest łatwe mapowanie obiektów na rekordy w bazie, co upraszcza operacje na danych oraz zapewnia wysoką wydajność w interakcjach z bazą danych.
\\\\
Kolejnym powodem wyboru .NET jest integracja z SignalR, technologią umożliwiającą dwukierunkową komunikację w czasie rzeczywistym. SignalR pozwala na szybką wymianę danych między klientem a serwerem, co jest kluczowe w przypadku aplikacji wymagających dynamicznych aktualizacji, takich jak powiadomienia, aktualizacje danych na żywo czy chaty. Dzięki tym technologiom .NET umożliwia tworzenie nowoczesnych, skalowalnych aplikacji webowych, które są szybkie, niezawodne i łatwe w utrzymaniu.
\\\\

\noindent \textbf{PostgreSQL i PgAdmin}\\
PostgreSQL to system lub silnik baz danych kompatybilny z większością popularnych narzędzi. Obsługuje różne modele danych w celu tworzenia wydajnych i skalowalnych aplikacji zorientowanych obiektowo. Umożliwia pracę ze złożonymi zbiorami danych, bez spowolnień. Ułatwia przechowywanie, odczyt i zapis danych. \cite{OVHPostgreSQL}
\\\\
PgAdmin to narzędzie do zarządzania PostgreSQL i pochodnymi relacyjnymi bazami danych, takimi jak EDB Advanced Server firmy EnterpriseDB. Może być uruchamiany jako aplikacja internetowa lub desktopowa. \cite{PgAdminFAQ}
\\\\
PostgreSQL został wybrany jako system bazodanowy z kilku kluczowych powodów. Przede wszystkim jest to wydajny, skalowalny i elastyczny system, który doskonale sprawdza się w pracy z dużymi zbiorami danych. Jego zaawansowane funkcje, takie jak obsługa różnych modeli danych oraz wsparcie dla danych obiektowych, umożliwiają łatwe zarządzanie bardziej złożonymi strukturami danych, co jest istotne w przypadku aplikacji wymagających dużej elastyczności.
\\\\
PgAdmin zostało wybrane jako narzędzie do zarządzania bazą danych PostgreSQL, ponieważ oferuje szeroką gamę funkcji umożliwiających łatwą administrację i kontrolę nad bazą. Umożliwia wykonywanie zapytań, zarządzanie tabelami, sprawdzanie i edytowanie danych, a także analizowanie struktury bazy. Dzięki przeczystemu interfejsowi, PgAdmin upraszcza proces zarządzania bazą danych, co pozwala na szybkie reagowanie na potrzeby projektu i skuteczną kontrolę nad danymi w systemie. Jest to wygodne narzędzie zarówno dla administratorów, jak i dla deweloperów, którzy potrzebują efektywnego środowiska do pracy z PostgreSQL.

\newpage

\subsection{Narzędzia pomocnicze}

\noindent \textbf{GIT i Github}\\
Git to rozproszony system kontroli wersji, co oznacza, że lokalny klon projektu jest kompletnym repozytorium kontroli wersji. Te w pełni funkcjonalne repozytoria lokalne ułatwiają pracę w trybie offline lub zdalnie. Deweloperzy zatwierdzają swoją pracę lokalnie, a następnie synchronizują kopię repozytorium z kopią na serwerze. Ten paradygmat różni się od scentralizowanej kontroli wersji, w której klienci muszą synchronizować kod z serwerem przed utworzeniem nowych wersji kodu. \cite{GitWhatIs}
\\\\
GitHub jest serwisem, który służy do współpracy przy tworzeniu kodu. Jest jednym z najpopularniejszych serwisów internetowych hostujących repozytoria Git w chmurze. Obsługiwane obszary serwisu obejmują nie tylko przechowywanie kodu, ale również zbieranie informacji o błędach, zarządzanie projektem oraz wszystkie niezbędne procesy automatycznego budowania i testowania aplikacji. Właśnie dlatego GitHub stał się centrum skupiającym programistów i środowisko otwartego oprogramowania. Serwisy typu GitHub stanowią stopień pośredni pomiędzy wykorzystaniem serwisu Git w tradycyjny sposób a systemami scentralizowanymi. \cite{CodersLabGitHub}
\\\\
Wybór Git i GitHub do zarządzania kodem wynikał przede wszystkim z ich popularności oraz dobrze znanej funkcjonalności, które są standardem w branży. Git to rozproszony system kontroli wersji, co oznacza, że każdy deweloper posiada pełną kopię repozytorium na swoim komputerze, umożliwiając pracę w trybie offline. Taki system zwiększa elastyczność i komfort pracy, umożliwiając zatwierdzanie zmian lokalnie i synchronizowanie ich z centralnym repozytorium na serwerze.
\\\\
GitHub został wybrany jako platforma do hostingu repozytoriów, ponieważ jest jednym z najpopularniejszych serwisów wspierających Git. Oferuje szeroką gamę funkcji, takich jak zarządzanie projektami, śledzenie błędów, automatyczne testowanie oraz integrację z innymi narzędziami. GitHub stał się centrum dla deweloperów, umożliwiając łatwą wymianę kodu, dokumentację oraz korzystanie z otwartego oprogramowania. Dzięki temu, Git i GitHub stanowią doskonałą kombinację do efektywnego zarządzania projektem.
\\\\

\noindent \textbf{Sourcetree}\\
Sourcetree to graficzny klient umożliwiający dostęp do repozytoriów Git i Mercurial z systemów Windows oraz MacOS, który pomaga wizualizować rozwój bez konieczności korzystania z wiersza polecenia. \cite{PolonTechSourceTree}
\\\\
SourceTree został wybrany ze względu na wygodę korzystania z jego graficznego interfejsu, który umożliwia łatwą obsługę repozytoriów Git bez potrzeby pisana komend wiersza poleceń. Dzięki temu narzędziu, możliwe jest wizualne śledzenie rozwoju projektu oraz zarządzanie wersjami w sposób bardziej intuicyjny. SourceTree oferuje przejrzysty interfejs, który pozwala na łatwe przeglądanie historii commitów, zarządzanie gałęziami, rozwiązywanie konfliktów oraz wykonywanie operacji Git za pomocą prostych kliknięć, co znacznie ułatwia pracę, zwłaszcza w większych projektach
\\\\

\noindent \textbf{Figma}\\
Figma to jedno z nowocześniejszych i cieszących się dużą popularnością narzędzi do projektowania i prototypownia stron internetowych i aplikacji mobilnych. Umożliwia tworzenie interaktywnych widoków w przeciwieństwie do statycznych makiet. Posiada bardzo uproszczony interfejs, a przy tym jest bardzo funkcjonalne. Figma zawiera jedynie niezbędne pakiety i narzędzia najczęściej wykorzystywane w pracy Web Designera, co przedkłada się na stosunkową małą wagę całego programu. Jego podstawową zaletą jest szybkość działania mimo otwartych kilkunastu widoków jednocześnie. Dodatkowo za pomocą Figmy można łatwo edytować dowolne pliki wektorowe w tym SVG, co znacznie przyspiesza pracę nad projektem. \cite{BoringOwlFigma}
\\\\
Figma jako zewnętrzny program zalazła zastosowanie w projekcie głownie do projektowania własnych ikon, nieistniejących bądź niedostępnych bezpłatnie na internecie. Zastosowanie prostego, ale bardzo efektywnego narzędzia ma duże znaczenie dla rozwoju aplikacji gry mobilnej, w szczegolnosci nakierowanej na przyjemny dla użytkownika interface. Dodatkowo Figma posłużyła do zaprojektowania i utworzenia modeli bierek do gry w szachy.  

\newpage

\section{Opis implementacji}

\subsection{System kontroli wersji}

\noindent
W projekcie wykorzystano system kontroli wersji Git, który pozwala na zarządzanie historią zmian w kodzie i efektywną współpracę w zespole. Git umożliwia pracę na lokalnych repozytoriach i synchronizację z centralnym repozytorium, co ułatwia śledzenie zmian, zarządzanie wersjami i przywracanie wcześniejszych stanów kodu w razie potrzeby.
\\\\
Do przechowywania repozytorium użyto GitHub, który umożliwia synchronizację kodu, zarządzanie gałęziami i udostępnianie projektu. Platforma oferuje narzędzia wspierające przegląd kodu, zgłaszanie błędów i automatyzację wdrożeń.

\vspace{0.5cm}
\begin{figure}[h!]
\centering
\includegraphics[width=1\textwidth]{images/gh_repo.png}
\caption{Repozytorium na stronie github.com}
\end{figure}
\vspace{0.5cm}

\noindent
W pracy z Git użyto także SourceTree, narzędzia z graficznym interfejsem, które upraszcza wykonywanie operacji takich jak commit, push czy merge. SourceTree ułatwia zarządzanie gałęziami, przeglądanie historii commitów oraz rozwiązywanie konfliktów, czyniąc te procesy bardziej intuicyjnymi i mniej czasochłonnymi.

\newpage

\subsection{Warstwa danych}

\subsubsection{Opis architektury bazy danych}

\noindent
Warstwa danych w aplikacji jest odpowiedzialna za zarządzanie przechowywaniem i dostępem do informacji w bazie danych. W omawianym projekcie wykorzystano system zarządzania bazą danych PostgreSQL, który jest jednym z najpopularniejszych rozwiązań bazodanowych o otwartym kodzie źródłowym.
\\\\
Z kolei do zarządzania interakcją z bazą danych w aplikacji zastosowano bibliotekę Entity Framework (EF), który jest popularny ORM dla platformy .NET. Pozwala on na mapowanie klas C\# na tabele w bazie danych, a także automatycznie generuje zapytania SQL na podstawie operacji na tych klasach. Dzięki EF, proces pracy z bazą danych jest znacznie uproszczony, ponieważ umożliwia on operowanie na obiektach w aplikacji, a nie bezpośrednio na tabelach bazy danych.
\\\\
W tej aplikacji, każda encja (klasa reprezentująca dane) jest mapowana na odpowiednią tabelę w bazie danych, a właściwości tych klas odpowiadają kolumnom w tabelach. Dzięki temu, zapisane dane w postaci obiektów w aplikacji mogą być łatwo zapisywane i pobierane z bazy, co zapewnia spójność i łatwość w zarządzaniu danymi.
\\\\
Do obsługi bazy danych, zarządzania danymi oraz monitorowania stanu bazy zastosowano narzędzie PgAdmin. Jest ono popularnym interfejsem graficznym dla PostgreSQL, który umożliwia łatwe zarządzanie bazą danych, tworzenie zapytań SQL, monitorowanie wydajności oraz przeprowadzanie operacji na danych, takich jak dodawanie, edytowanie czy usuwanie rekordów. Dzięki temu narzędziu możliwe jest szybkie i wygodne wykonywanie operacji administracyjnych oraz wgląd w strukturę bazy danych, co wspiera procesy utrzymania aplikacji.
\\\\
Poniżej zaprezentowane zostały diagramy ERD (Entity-Relationship Diagram), które ilustrują strukturę bazy danych oraz relacje pomiędzy encjami. Każda z tych encji odpowiada za przechowywanie specyficznych danych, które są następnie wykorzystywane przez różne warstwy aplikacji w celu zapewnienia pełnej funkcjonalności systemu. Opis poszczególnych encji i ich zależności pozwala na lepsze zrozumienie, jak dane są przechowywane i powiązane w systemie.

\newpage

\subsubsection{Schemat bazy danych}

\noindent \textbf{Relacje użytkownika}\\
Segment relacji z użytkownikami obejmuje kilka encji i ich relacji, które zarządzają danymi użytkownika. Encja \texttt{User} jest rdzeniem tego segmentu i jest powiązany z wieloma innymi jednostkami. Każdy użytkownik jest powiązany z rolą, która definiuje uprawnienia użytkownika w systemie, a relacja między nimi jest ustanawiana za pomocą klucza obcego na \texttt{RoleId}. Ponadto każdy użytkownik jest powiązany z kodem weryfikacyjnym do celów weryfikacji w relacji ta jest jeden do jednego. Encje reprezentujące obrazy przechowują dane związane z zdjęciami, tworząc relacje jeden-do-jednego z podmiotem User. Jednostki odpowiadające za śledzenie ranking i statystyki użytkownika i są również powiązane z jednostką \texttt{User} poprzez relacje jeden-do-jednego. Sama jednostka \texttt{User} jest powiązana także z kilkoma innymi encjami łącząc pozostałem segment w jedną całość.

\vspace{0.5cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{images/ERD_user.png}
    \caption{Diagram relacji jednostka-relacja przedstawiający relacje użytkownika. Wygenerowany za pomocą programu PgAdmin.}
\end{figure}

\newpage

\noindent \textbf{Relacje znajomości}\\
Segment relacji przyjaźni jest zarządzany przez jednostkę przyjaźni, która reprezentuje połączenia społeczne między użytkownikami. Każda Encja \texttt{Friendship} ma dwóch kluczowych uczestników: \texttt{Requestor} (przyjmujacy) i \texttt{Receiver} (odbierający). Są to obaj użytkownicy, a relacje między tymi podmiotami są modelowane za pomocą kluczy obcych: \texttt{RequestorId} i \texttt{ReceiverId}. Ta relacja jest wiele-do-jednego, co oznacza, że użytkownik może mieć wiele przyjaźni zarówno jako żądający, jak i odbiorca. Dodatkowo, istnieje jednostka statystyk przyjaźni śledząca statystyki związane z każdą przyjaźnią, tworząc relację jeden-do-jednego z encją \texttt{Friendship}. Same znajomości są grupowane na podstawie pola \texttt{Status}, który jest wartością wyliczeniową, określającą rodzaj znajomości - są to relacje zaakceptowane, oczekujące i zablokowane.

\vspace{0.5cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{images/ERD_friendship.png}
    \caption{Diagram relacji między podmiotami przedstawiający relacje przyjaźni między użytkownikami. Wygenerowany za pomocą programu PgAdmin.}
\end{figure}

\newpage

\noindent \textbf{Relacje w grach sieciowych}\\
Segment relacji gier online obsługuje strukturę internetowej gry w szachy, z kilkoma jednostkami, które śledzą różne aspekty gry. Jednostka \texttt{WebGame} jest główną w tym segmencie i reprezentuje samą grę, łącząc dwóch graczy poprzez relacje jeden-do-jednego. Stan i czas gry są kontrolowane przez osobne encje, które są połączone za pomocą kluczy obcych. Jednostka \texttt{WebGamePlayer} służy do zapisywania informacji specyficznych dla gracza i odwołuje się do jednostki \texttt{User} - użytkownik posiada wielu graczy. Ruchy wykonane w grze są przechowywane w osobnej tabli, która ma relację wiele do jednego z główną encję gry. Dodatkowo, wiadomości wymieniane podczas gry są obsługiwane przez encje dwa osobne obiekty, tworzące relacje wiele-do-jednego odpowiednio z encjami samej gry jak i gracza.

\vspace{0.5cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{images/ERD_online.png}
    \caption{Diagram relacji między podmiotami ilustrujący strukturę interakcji w grach sieciowych. Wygenerowany za pomocą programu PgAdmin.}
\end{figure}

\newpage

\noindent \textbf{Relacje w grach z silnikiem}\\
Segment ten skupia się na aspekcie gry opartym na silniku, gdzie każda gra jest zarządzana przez encję \texttt{EngineGame}. Encja ta jest powiązana z encją gracza, reprezentującą użytkownika, który gra w grę opartą na silniku, a relacja jeden-do-jednego jest ustanawiana poprzez parametr \texttt{PlayerId}. Każdy ruch w grze jest przechwytywany w tabeli ruchów, która jest powiązana z główną encją poprzez klucz obcy. Encja stanu gry przechowuje aktualny stan gry opartej na silniku i jest powiązana z \texttt{EngineGame} poprzez relację jeden-do-jednego. Dodatkowo, wiadomości specyficzne dla gier silnikowych są przechowywane w osobnej liscie obiektów, która jest powiązana z \texttt{EngineGame} poprzez klucz obcy.

\vspace{0.5cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{images/ERD_offline.png}
    \caption{Diagram zależności między jednostkami przedstawiający relacje między silnikiem a grą. Wygenerowany za pomocą programu PgAdmin.}
\end{figure}

\newpage

\subsubsection{Opis encji}

\noindent
W ramach warstwy danych aplikacji, encje pełnią kluczową rolę w odwzorowywaniu struktury danych, które są przechowywane w bazie danych. W tym rozdziale przedstawione zostały wszystkie encje projektu, ich właściwości oraz powiązania między nimi. Każda z encji odpowiada za przechowywanie danych dotyczących określonych elementów systemu, takich jak użytkownicy, gry czy relacje, a ich odpowiedniki w bazie danych są realizowane za pomocą tabel.
\\\\
Ważnym aspektem w projekcie jest wykorzystanie klas abstrakcyjnych, które stanowią wspólne podstawy dla encji reprezentujących różne, ale podobne obiekty w systemie. Klasy abstrakcyjne nie mają swojego odwzorowania w bazie danych, jednak pełnią rolę pośredników, umożliwiając dziedziczenie i tworzenie bardziej specyficznych encji. Na przykład, encje reprezentujące gry sieciowe oraz gry z komputerem dziedziczą po klasach abstrakcyjnych, które definiują wspólne właściwości dla wszystkich gier. Jednak szczegóły, takie jak obecność kontroli czasu, różnią się w zależności od typu gry — gry online mogą mieć kontrolę czasu, podczas gdy gry offline nie.
\\\\
W samych encjach zdefiniowane są również powiązania z innymi encjami, które realizowane są przez klucze obce. Klucze obce są zapisane jako kolumny w tabelach, przyjmujące postać identyfikatorów powiązanych encji. Dzięki temu możliwe jest tworzenie odpowiednich relacji pomiędzy danymi w różnych tabelach. W przypadku relacji jeden do wielu, zastosowanie znajdują listy, które umożliwiają przypisanie wielu obiektów do jednej encji.
\\\\
Encje w projekcie zostały podzielone logicznie, zgodnie z rolą, jaką pełnią w systemie. Na przykład, encja użytkownika jest powiązana z encją punktacji, jednak punktacja jest przechowywana w osobnej tabeli, ponieważ jest używana do konkretnych, innych funkcjonalności niż sam User. Dzięki takiemu podziałowi możliwe jest bardziej elastyczne zarządzanie danymi oraz lepsze odwzorowanie relacji pomiędzy różnymi elementami systemu.

\newpage

\noindent \textbf{Abstrakcyjne jednostki}\\

\begin{itemize}
    \item \textbf{Game}\\
    Klasa dziedziczona przez podmioty reprezentujące gry Deklaruje podstawowe właściwości jakie powinna posiadać każda gra.
    \renewcommand{\arraystretch}{1.2}
    \begin{longtable}{|m{4cm}|m{2cm}|m{8cm}|}
        \hline
        \rowcolor{lightgray}
        \textbf{Właściwość} & \textbf{Typ} & \textbf{Opis} \\ \hline
        \endhead
        \hline
        Position & string & Aktualna pozycja na szachownicy \\ \hline
        HasEnded & bool & Flaga, czy gra się zakończyła \\ \hline
        CreatedAt & DateTime & Data utworzenia gry \\ \hline
        StartedAt & DateTime? & Data rozpoczęcia gry \\ \hline
        EndedAt & DateTime? & Data zakończenia gry \\ \hline
        Turn & int & Numer tury gry \\ \hline
        Round & int & Numer rundy \\ \hline
        WinnerColor & enum? & Kolor zwycięzcy (null oznacza remis) \\ \hline
    \end{longtable}

    \item \textbf{GameState}\\
    Abstrakcyjna encja reprezentująca stan gry. Dotyczy głównie ruchów specjalnych, charakteryzujących się szczególnymi zasadami.
    \renewcommand{\arraystretch}{1.2}
    \begin{longtable}{|m{4cm}|m{2cm}|m{8cm}|}
        \hline
        \rowcolor{lightgray}
        \textbf{Właściwość} & \textbf{Typ} & \textbf{Opis} \\ \hline
        \endhead
        \hline
        EnPassant & string? & Koordynaty dla bicia en passant \\ \hline
        (Can castle) & bool & Pola określające, prawa do roszady \\ \hline
        HalfMove & int & Liczba ruchów nie będących pionkiem  \\ \hline
    \end{longtable}

    \item \textbf{Player}\\
    Generalna klasa przechowują podstawowe dane reprezentujące gracza.
    \renewcommand{\arraystretch}{1.2}
    \begin{longtable}{|m{4cm}|m{2cm}|m{8cm}|}
        \hline
        \rowcolor{lightgray}
        \textbf{Właściwość} & \textbf{Typ} & \textbf{Opis} \\ \hline
        \endhead
        \hline
        Name & string & Nazwa gracza (nazwa użytkownika) \\ \hline
        Color & enum? & Kolor bierek gracza \\ \hline
        CreatedAt & DateTime & Data utworzenia gracza \\ \hline
    \end{longtable}

\newpage

    \item \textbf{Move}\\
    Abstrakcyjna encja przedstawiająca ruch wykonany podczas rozgrywki. Jednoznacznie identyfikuje informacje o stanie gry po wykonaniu ruchu podczas gry.
    \renewcommand{\arraystretch}{1.2}
    \begin{longtable}{|m{4cm}|m{2cm}|m{8cm}|}
        \hline
        \rowcolor{lightgray}
        \textbf{Właściwość} & \textbf{Typ} & \textbf{Opis} \\ \hline
        \endhead
        \hline
        DoneMove & string & Wykonany ruch w formacie: tag figury + x (jeśli zbicie) + współrzędne xy \\ \hline
        FenMove & string & Wykonany ruch w formacie FEN \\ \hline
        OldCoordinates & string & Współrzędne, z których figura została przemieszczona w formacie x,y \\ \hline
        NewCoordinates & string & Współrzędne, na które figura została przemieszczona w formacie x,y \\ \hline
        Position & string & Pozycja na szachownicy po wykonaniu ruchu \\ \hline
        Turn & int & Tura, w której ruch został wykonany \\ \hline
        CapturedPiece & string? & Tag zbitej figury \\ \hline
        DoneAt & DateTime & Data i godzina wykonania ruchu \\ \hline
    \end{longtable}

    \item \textbf{Message}\\
    Generalna encja reprezentująca wiadomości tworzone podczas gry (automatycznie i poprzez użytkowników).
    \renewcommand{\arraystretch}{1.2}
    \begin{longtable}{|m{4cm}|m{2cm}|m{8cm}|}
        \hline
        \rowcolor{lightgray}
        \textbf{Właściwość} & \textbf{Typ} & \textbf{Opis} \\ \hline
        \endhead
        \hline
        Content & string & Treść wiadomości \\ \hline
        SentAt & DateTime & Data i godzina wysłania wiadomości \\ \hline
        Type & enum & Typ wiadomości (automatyczna / wysłana) \\ \hline
    \end{longtable}

    \item \textbf{Image}\\
    Abstrakcyjna klasa reprezentująca pliki graficzne.
    \renewcommand{\arraystretch}{1.2}
    \begin{longtable}{|m{4cm}|m{2cm}|m{8cm}|}
        \hline
        \rowcolor{lightgray}
        \textbf{Właściwość} & \textbf{Typ} & \textbf{Opis} \\ \hline
        \endhead
        \hline
        Data & byte[] & Dane obrazu w postaci bajtów \\ \hline
        ContentType & string & Typ zawartości obrazu \\ \hline
    \end{longtable}
\end{itemize}

\newpage

\noindent \textbf{Tabele bazy danych}\\

\begin{itemize}
    \item \textbf{Roles}\\
    Określa role użytkowników w systemie, takie jak "User" i "Admin".

    \item \textbf{DataConfigurations}\\
    Zawiera ustawienia konfiguracji dla kluczowych pól użytkownika (takie jak hasło i nazwa użytkownika). Nie jest powiązana z żadną inną jednostką.

    \item \textbf{Users}\\
    Główna encja reprezentująca użytkownika.
    \renewcommand{\arraystretch}{1.2}
    \begin{longtable}{|m{4cm}|m{2cm}|m{8cm}|}
        \hline
        \rowcolor{lightgray}
        \textbf{Właściwość} & \textbf{Typ} & \textbf{Opis} \\ \hline
        \endhead
        \hline
        Id & Guid & Identyfikator użytkownika (PK) \\ \hline
        IsVerified & bool & Czy email użytkownika jest zweryfikowany \\ \hline
        IsPrivate & bool & Czy profil użytkownika jest widoczny przez innych użytkowników \\ \hline
        Email & string & Adres email użytkownika \\ \hline
        Username & string & Unikalna nazwa użytkownika \\ \hline
        Name & string? & Opcjonalne pełne imię i nazwisko \\ \hline
        PasswordHash & string & Zahashowane hasło użytkownika \\ \hline
        JoinDate & DateTime & Data dołączenia użytkownika do systemu \\ \hline
        Country & string & Kraj, w którym użytkownik się zarejestrował \\ \hline
        Bio & string? & Krótkie bio lub opis użytkownika \\ \hline
        RoleId & int & Identyfikator roli użytkownika\\ \hline
    \end{longtable}

    \item \textbf{UserElos}\\
    Punktacja użytkownika dla poszczególnych trybów czasowych gry.
    \renewcommand{\arraystretch}{1.2}
    \begin{longtable}{|m{4cm}|m{2cm}|m{8cm}|}
        \hline
        \rowcolor{lightgray}
        \textbf{Właściwość} & \textbf{Typ} & \textbf{Opis} \\ \hline
        \endhead
        \hline
        Id & Guid & Identyfikator ELO (PK) \\ \hline
        (Kategorii kontroli) & int & Punkty dla trybu kontroli czasowej \\ \hline
        UserId & Guid & Identyfikator użytkownika, do którego należy punktacja \\ \hline
    \end{longtable}

\newpage

    \item \textbf{UserVerificationCodes}\\
    Tablica kodów weryfikacyjnych. Kody dzielą się na dwa typy, ze względu na rodzaj przeznaczenia - dotyczące weryfikacji kota oraz odzyskiwania hasła.
    \renewcommand{\arraystretch}{1.2}
    \begin{longtable}{|m{4cm}|m{2cm}|m{8cm}|}
        \hline
        \rowcolor{lightgray}
        \textbf{Właściwość} & \textbf{Typ} & \textbf{Opis} \\ \hline
        \endhead
        \hline
        Id & Guid & Identyfikator kodu weryfikacyjnego (PK) \\ \hline
        CodeHash & string & Zahashowany kod używany do weryfikacji \\ \hline
        ExpirationDate & DateTime & Data wygaśnięcia kodu weryfikacyjnego \\ \hline
        Type & enum & Typ kodu weryfikacyjnego \\ \hline
        UserId & Guid & Identyfikator użytkownika \\ \hline
    \end{longtable}

    \item \textbf{UserStats}\\
    Tablica statystyki użytkownika.
    \renewcommand{\arraystretch}{1.2}
    \begin{longtable}{|m{4cm}|m{2cm}|m{8cm}|}
        \hline
        \rowcolor{lightgray}
        \textbf{Właściwość} & \textbf{Typ} & \textbf{Opis} \\ \hline
        \endhead
        \hline
        Id & Guid & Identyfikator statystyk użytkownika (PK) \\ \hline
        (Statystyki gier) & int & Zawiera różnorodne dane liczbowe dotyczące statystyk gier użytkownika \\ \hline
        UserId & Guid & Identyfikator użytkownika \\ \hline
    \end{longtable}

    \item \textbf{UserSettings}\\
    Globalne ustawienia konta oraz gier.
    \renewcommand{\arraystretch}{1.2}
    \begin{longtable}{|m{4cm}|m{2cm}|m{8cm}|}
        \hline
        \rowcolor{lightgray}
        \textbf{Właściwość} & \textbf{Typ} & \textbf{Opis} \\ \hline
        \endhead
        \hline
        Id & Guid & Identyfikator ustawień użytkownika (PK) \\ \hline
        (Ustawienia gry) & enum, bool & Określa ustawienia dotyczące gier \\ \hline
        UserId & Guid & Identyfikator użytkownika \\ \hline
    \end{longtable}

    \item \textbf{UserProfileImage oraz UserBackgroundImages}\\
    zdjęcia użytkownika. Powiązane w relacja jeden-do-jeden z użytkownikiem. Dziedziczą po klasie abstrakcyjnej \texttt{Image}, reprezentującą zapisane zdjęcia.

\newpage

    \item \textbf{Friendships}\\
    Tablica relacji pomiędzy użytkownikami.
    \renewcommand{\arraystretch}{1.2}
    \begin{longtable}{|m{4cm}|m{2cm}|m{8cm}|}
        \hline
        \rowcolor{lightgray}
        \textbf{Właściwość} & \textbf{Typ} & \textbf{Opis} \\ \hline
        \endhead
        \hline
        Id & Guid & Identyfikator relacji przyjaźni (PK) \\ \hline
        Status & enum & Status przyjaźni  \\ \hline
        RequestCreatedAt & DateTime & Data utworzenia/złożenia wniosku o przyjaźń \\ \hline
        RequestRespondedAt & DateTime? & Data, kiedy druga strona odpowiedziała na wniosek o przyjaźń \\ \hline
        RequestorId & Guid & Identyfikator użytkownika, który wysłał prośbę o przyjaźń \\ \hline
        ReceiverId & Guid & Identyfikator użytkownika, który otrzymał prośbę o przyjaźń \\ \hline
    \end{longtable}

    \item \textbf{FriendshipStats}\\
    Statystki dotyczące relacji użytkowników.
    \renewcommand{\arraystretch}{1.2}
    \begin{longtable}{|m{4cm}|m{2cm}|m{8cm}|}
        \hline
        \rowcolor{lightgray}
        \textbf{Właściwość} & \textbf{Typ} & \textbf{Opis} \\ \hline
        \endhead
        \hline
        Id & Guid & Identyfikator statystyk przyjaźni (PK) \\ \hline
        RequestorWins & int & Liczba wygranych gier użytkownika inicjującego relację \\ \hline
        RequestorLoses & int & Liczba przegranych gier użytkownika inicjującego relację \\ \hline
        RequestorDraws & int & Liczba remisów gier użytkownika inicjującego relację \\ \hline
        GamesPlayed & int & Całkowita liczba gier rozegranych w relacji \\ \hline
        FriendshipId & Guid & Identyfikator relacji przyjaźni, do której należą statystyki \\ \hline
    \end{longtable}
  
\newpage

    \item \textbf{WebGames}\\
    Gry online między użytkownikami. Każda gra zawiera powiązanie do dwóch gracz - oznaczonego jako białego i czarnego w zależności od strony jaką przyjmują. WebGame dziedziczy po abstrakcyjnej klasie gry.
    \renewcommand{\arraystretch}{1.2}
    \begin{longtable}{|m{4cm}|m{2cm}|m{8cm}|}
        \hline
        \rowcolor{lightgray}
        \textbf{Właściwość} & \textbf{Typ} & \textbf{Opis} \\ \hline
        \endhead
        \hline
        Id & Guid & Identyfikator gry online (PK) \\ \hline
        IsPrivate & bool & Czy gra jest prywatna czy publiczna \\ \hline
        TimingType & enum & Typ czasu gry (np. Bullet, Blitz, Rapid) \\ \hline
        EndGameType & enum? & Powód zakończenia gry (np. mat, czas) \\ \hline
        EloGain & int & Zysk lub strata Elo po zakończeniu gry \\ \hline
        WhitePlayerId & Guid & Identyfikator gracza grającego białymi \\ \hline
        BlackPlayerId & Guid & Identyfikator gracza grającego czarnymi \\ \hline
        GameTimingId & Guid & Identyfikator ustawień czasu gry \\ \hline
    \end{longtable}

    \item \textbf{WebGamePlayers}\\
    Tablica graczy gry online, reprezentujące użytkownika jako gracza należącego do gry. Dziedziczy po klasie Player oraz zawiera dodatkowe elementy, ze względu an czasowy charakter gry.
    \renewcommand{\arraystretch}{1.2}
    \begin{longtable}{|m{4cm}|m{2cm}|m{8cm}|}
        \hline
        \rowcolor{lightgray}
        \textbf{Właściwość} & \textbf{Typ} & \textbf{Opis} \\ \hline
        \endhead
        \hline
        Id & Guid & Identyfikator gracza (PK) \\ \hline
        IsPrivate & bool & Czy gracz do globalnych gier, czy prywatnych \\ \hline
        IsPlaying & bool & Czy gracz wciąż szuka gry \\ \hline
        IsTemp & bool & Czy gracz jest tymczasowy \\ \hline
        FinishedGame & bool & FCzy gra dla gracza została zakończona \\ \hline
        Elo & int & Punkty Elo dla konkretnego typu czasu \\ \hline
        TimeLeft & double & Czas pozostały na wykonanie ruchów \\ \hline
        TimingId & Guid & Id typu czasu \\ \hline
        UserId & Guid & Id użytkownika, któremu gracz należy \\ \hline
        GameId & Guid & Id gry, w której gracz bierze udział \\ \hline
    \end{longtable}
 
\newpage

    \item \textbf{GameTimings}\\
    Kontrole czasowe dla gier z ograniczeniem czasu. Kontrola czasowa jest powiązana w grami w relacji jeden do wielu, co oznacza, że jeden rodzaj kontroli jest wykorzystywany w wielu grach.
    \renewcommand{\arraystretch}{1.2}
    \begin{longtable}{|m{4cm}|m{2cm}|m{8cm}|}
        \hline
        \rowcolor{lightgray}
        \textbf{Właściwość} & \textbf{Typ} & \textbf{Opis} \\ \hline
        \endhead
        \hline
        Id & Guid & Identyfikator ustawienia czasu gry (PK) \\ \hline
        Type & enum & Kategoria (typ) kontroli czasu \\ \hline
        Seconds & int & Czas trwania gry w sekundach \\ \hline
        Increment & int & Inkrement czasowy w sekundach \\ \hline
    \end{longtable}

    \item \textbf{WebGameStates}\\
    Stan gry online, przechowuje dane szczególne dotyczące obecnej gry. Dziedziczy w abstrakcyjnej klasie stanów gry.
    
    \item \textbf{WebGameInvitations}\\
    Opcjonalne zaproszenia do gry. Generowane tylko do gier prywatach i służące do mechanizmów związanych z zapraszaniem do gry i odpowiedziami na zaproszenia.
    \renewcommand{\arraystretch}{1.2}
    \begin{longtable}{|m{4cm}|m{2cm}|m{8cm}|}
        \hline
        \rowcolor{lightgray}
        \textbf{Właściwość} & \textbf{Typ} & \textbf{Opis} \\ \hline
        \endhead
        \hline
        Id & Guid & Identyfikator zaproszenia (PK) \\ \hline
        InviterId & Guid & Identyfikator użytkownika zapraszającego \\ \hline
        InviteeId & Guid & Identyfikator użytkownika zapraszanego \\ \hline
        InviterName & string & Nazwa użytkownika zapraszającego do relacji \\ \hline
        InviteeName & string & Nazwa użytkownika zaproszonego do relacji \\ \hline
        CreatedAt & DateTime & Data utworzenia zaproszenia \\ \hline
        Type & enum & Typ kontroli czasowej \\ \hline
        IsAccepted & bool & Czy zaproszenie zostało zaakceptowane \\ \hline
        GameId & Guid & Id gry, do której należy zaproszenie \\ \hline
    \end{longtable}

\newpage

    \item \textbf{WebGameMove}\\
    Ruchy wykonane podczas gry online. Dziedziczy po klasie Move, a dodatkowo ze względu na kontrole czasową występującą w grach między użytkownikami zawiera pola związane z czasem.
    \renewcommand{\arraystretch}{1.2}
    \begin{longtable}{|m{4cm}|m{2cm}|m{8cm}|}
        \hline
        \rowcolor{lightgray}
        \textbf{Właściwość} & \textbf{Typ} & \textbf{Opis} \\ \hline
        \endhead
        \hline
        Id & Guid & Identyfikator ruchu (PK) \\ \hline
        WhiteTime & double & Czas pozostały dla białego gracza \\ \hline
        BlackTime & double & Czas pozostały dla czarnego gracza \\ \hline
        MoveDuration & TimeSpan & Czas, który gracz zużył na wykonanie ruchu \\ \hline
        GameId & Guid & Identyfikator gry, do której ruch należy \\ \hline
    \end{longtable}
        
    \item \textbf{WebGameMessages}\\
    Wiadomości systemowe dotyczące gry online. Otrzymują własności po generalnej klasnie reprezentującą wiadomości. 
    \renewcommand{\arraystretch}{1.2}
    \begin{longtable}{|m{4cm}|m{2cm}|m{8cm}|}
        \hline
        \rowcolor{lightgray}
        \textbf{Właściwość} & \textbf{Typ} & \textbf{Opis} \\ \hline
        \endhead
        \hline
        Id & Guid & Identyfikator ruchu (PK) \\ \hline
        GameId & Guid & Identyfikator gry, do której wiadomość należy \\ \hline
    \end{longtable}

    \item \textbf{WebGamePlayerMessages}\\
    Wiadomości wysłane przez graczy podczas gry online. Dziedziczą wartości po abstrakcyjnej klasie Message.
    \renewcommand{\arraystretch}{1.2}
    \begin{longtable}{|m{4cm}|m{2cm}|m{8cm}|}
        \hline
        \rowcolor{lightgray}
        \textbf{Właściwość} & \textbf{Typ} & \textbf{Opis} \\ \hline
        \endhead
        \hline
        Id & Guid & Identyfikator ruchu (PK) \\ \hline
        PlayerId & Guid & Identyfikator gracza, do którego wiadomość należy \\ \hline
    \end{longtable}
    
\newpage
    
    \item \textbf{EngineGames}\\
    Tablica gier offline z silnikiem szachowym. Dziedziczy także podobnie jak w przypadku gier online po abstrakcyjnej klasie Game.  
    \renewcommand{\arraystretch}{1.2}
    \begin{longtable}{|m{4cm}|m{2cm}|m{8cm}|}
        \hline
        \rowcolor{lightgray}
        \textbf{Właściwość} & \textbf{Typ} & \textbf{Opis} \\ \hline
        \endhead
        \hline
        Id & Guid & Identyfikator gry (PK) \\ \hline
        EngineLevel & int & Poziom głębokości silnika \\ \hline
        EloGain & int & Zysk lub strata Elo po zakończeniu gry \\ \hline
        PlayerId & Guid & Identyfikator gracza \\ \hline
    \end{longtable}
    
    \item \textbf{EngineGameStates}\\
    Stan gry offline, przechowuje dane szczególne dotyczące obecnej gry. Implementuje własności z abstrakcyjnej klasy stanów gry.

    \item \textbf{EngineGamePlayers}\\
    Gracze gier offline, reprezentujące użytkownika jako gracza w grze z silnikiem szachowym. Dziedziczy podstawowe dane po klasie Player.
    \renewcommand{\arraystretch}{1.2}
    \begin{longtable}{|m{4cm}|m{2cm}|m{8cm}|}
        \hline
        \rowcolor{lightgray}
        \textbf{Właściwość} & \textbf{Typ} & \textbf{Opis} \\ \hline
        \endhead
        \hline
        Id & Guid & Identyfikator gracza (PK) \\ \hline
        Elo & int & Punkty Elo dla gier przeciwko silnikowi \\ \hline
        UserId & Guid & Identyfikator użytkownika, do którego należy gracz \\ \hline
        GameId & Guid & Identyfikator gry, w której gracz bierze udział \\ \hline
    \end{longtable}
    
    \item \textbf{EngineGameMoves}\\
    Ruchy wykonane podczas gry offline. Dziedziczą po abstrakcyjnej klasie ruchu oraz nie implementują żadnych własnych właściwości.
    \renewcommand{\arraystretch}{1.2}
    \begin{longtable}{|m{4cm}|m{2cm}|m{8cm}|}
        \hline
        \rowcolor{lightgray}
        \textbf{Właściwość} & \textbf{Typ} & \textbf{Opis} \\ \hline
        \endhead
        \hline
        Id & Guid & Identyfikator ruchu (PK) \\ \hline
        GameId & Guid & Identyfikator gry, do której ruch należy \\ \hline
    \end{longtable}
    
    \item \textbf{EngineGameMessages}\\
    Automatyczne wiadomości dotyczące gry offline. Zaprojektowane identycznie jak w przypadku wiadomości aromatycznych gie online.
    
\end{itemize}

\newpage

\subsection{Warstwa Serwerowa (Backend)} 

\subsubsection{Architektura i struktura} 

\noindent
Architektura backendu oparta jest na Onion Architecture, która zapewnia modularność, izolację logiki biznesowej oraz odwrócenie zależności. Dzięki temu aplikacja może być rozwijana niezależnie od technologii. Struktura składa się z warstw komunikujących się przez jasno zdefiniowane interfejsy, chroniąc rdzeń aplikacji przed zmianami w zewnętrznych zależnościach i technologiach.

\vspace{0.5cm}
\begin{figure}[h!] 
    \centering 
    \includegraphics[width=0.7\textwidth]{images/struktura_back.png} 
    \caption{Struktura projektów solucji warstwy serwerowej.} 
\end{figure}
\vspace{0.5cm}

\noindent \textbf{Zalety Onion Architecture:}
\begin{itemize}
    \item \textbf{Izolacja logiki biznesowej:} pozwala na pełną separację logiki biznesowej od zewnętrznych zależności, co umożliwia łatwe testowanie i modyfikowanie samej logiki bez wpływu na resztę systemu.
    \item \textbf{Skalowalność i elastyczność:} modularność struktury pozwala na łatwą rozbudowę systemu, poprzez dodawanie nowych warstw lub rozszerzanie istniejących komponentów bez ryzyka wprowadzenia chaosu w kodzie.
    \item \textbf{Testowalność:} dzięki wyodrębnieniu warstw odpowiedzialnych za różne aspekty systemu, testowanie staje się prostsze i bardziej zorganizowane, ponieważ możemy testować poszczególne warstwy niezależnie.
    \item \textbf{Odwrócenie zależności:} warstwa zewnętrzna może korzystać z funkcjonalności warstw wewnętrznych, ale nie odwrotnie. To oznacza, że zmiany w bazach danych czy frameworkach nie wpływają na logikę biznesową aplikacji.
\end{itemize}

\newpage

\noindent
Zależności między poszczególnymi modułami zaprezentowane zostały za pomocą grafu, co pozwala na wizualizację i lepsze zrozumienie interakcji między warstwami. Graf ten odzwierciedla zasady Onion Architecture, w której zależności zawsze kierują się do wewnątrz, tj. od warstw zewnętrznych do bardziej wewnętrznych.
\\\\
Moduł .Api zależy wyłącznie od warstwy .Application, co oznacza, że obsługuje żądania i deleguje ich przetwarzanie do przypadków użycia w .Application. Z kolei .Application komunikuje się z modułem .Core, który definiuje kluczowe modele domenowe. Warstwa .Core pozostaje całkowicie niezależna od innych modułów, co jest zgodne z zasadami odwrócenia zależności. Moduł .Infrastructure implementuje interfejsy zdefiniowane w .Application, dostarczając szczegóły techniczne, takie jak integracje czy dostęp do danych, ale nie wymusza zależności zwrotnej na rdzeniu. .Shared działa jako pomocniczy moduł, który może być używany przez dowolną warstwę, dostarczając wspólny kod i narzędzia.

\vspace{0.5cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{images/diagram_dependencies.png}
    \caption{Diagram zależności między projektami. Opracowany za pomocą aplikacji Viso.}
\end{figure}

\newpage

\noindent \textbf{Warstwa prezentacji}\\
Moduł \texttt{chess.Api} pełni funkcję warstwy zewnętrznej, odpowiedzialnej za obsługę żądań HTTP oraz przekazywanie ich do odpowiednich komponentów logiki aplikacji. Jest to punkt wejściowy dla użytkowników lub zewnętrznych integracji. Warstwa ta korzysta z usług dostarczanych przez moduł Application, pozostając przy tym niezależna od szczegółów implementacyjnych niższych warstw.

\vspace{0.5cm}
\noindent
\begin{minipage}[t]{0.5\textwidth}
    \vspace{0pt}
    \justifying 
    \noindent
    Warstwa prezentacji zawiera kontrolery realizujące logikę obsługi poszczególnych zasobów oraz huby, które obsługują komunikację w czasie rzeczywistym. Modele reprezentują dane odbierane z endpointów aplikacji, mapy przekształcają te modele na żądania odpowiadające wymaganiom warstwy aplikacyjnej. Moduł zapewnia również mechanizmy autoryzacji, umożliwiające kontrolę dostępu do zasobów i operacji.
\end{minipage}
\hfill
\begin{minipage}[t]{0.4\textwidth}
    \vspace{0pt}
    \centering
    \includegraphics[width=\linewidth]{images/struktura_back_api.png}
    \captionof{figure}{Str. .Api.}
\end{minipage}
\vspace{0.5cm}

\noindent \textbf{Warstwa aplikacji}\\
Moduł \texttt{chess.Application} zawiera logikę aplikacyjną, w tym definicje przypadków użycia, które realizują wymagania systemowe. Jest on pośrednikiem między warstwą interfejsu (Api) a rdzeniem systemu, reprezentowanym przez moduł Core. Dzięki temu logika biznesowa jest chroniona przed szczegółami technicznymi, takimi jak sposób przetwarzania żądań czy dostęp do danych.

\vspace{0.5cm}
\noindent
\begin{minipage}[t]{0.4\textwidth}
    \vspace{0pt}
    \centering
    \includegraphics[width=\linewidth]{images/struktura_back_application.png} 
    \captionof{figure}{Str. .Application.}
\end{minipage}
\hfill
\begin{minipage}[t]{0.5\textwidth}
    \vspace{0pt}
    \justifying \noindent
    Warstwa aplikacji zawiera interfejsy dla hubów SignalR (Hubs), repozytoriów (Repositories) i usług (Services), definiujące kluczowe kontrakty. W Requests znajdują się żądania obsługiwane przez MediatR, wspierające wzorzec CQRS. Moduł Pagination dostarcza abstrakcje do paginacji wyników, istotne przy operacjach na dużych zbiorach danych.
\end{minipage}

\newpage

\noindent \textbf{Warstwa dostępu do danych}\\
Moduł \texttt{chess.Infrastructure} obsługuje szczegóły techniczne, takie jak dostęp do bazy danych czy integracje z usługami. Implementuje on interfejsy zdefiniowane w Application, zapewniając zgodność z wymogami logiki biznesowej.

\vspace{0.5cm}
\noindent
\begin{minipage}[t]{0.5\textwidth}
    \vspace{0pt}
    \justifying 
    \noindent
    W folderze Contexts znajduje się klasa kontekstu bazy danych, która mapuje encje aplikacji na tabele, a konfigurowanie encji znajduje się w folderze Configuration. Foldery Services i Repositories zawierają implementacje interfejsów zdefiniowanych w warstwie aplikacji. Workers to klasy odpowiedzialne za zadania cykliczne. Migrations natomiast zawiera skrypty migracji bazy danych, umożliwiające zarządzanie zmianami w schemacie bazy danych.
\end{minipage}
\hfill
\begin{minipage}[t]{0.4\textwidth}
    \vspace{0pt}
    \centering
    \includegraphics[width=\linewidth]{images/struktura_back_infrastructure.png} 
    \captionof{figure}{Str. .Infrastructure.}
\end{minipage}
\vspace{0.5cm}

\noindent \textbf{Warstwa logiki biznesowej}\\
Moduł \texttt{chess.Core} stanowi serce aplikacji i zawiera jej logikę biznesową oraz kluczowe modele domenowe. Jest to najbardziej niezależna warstwa, która nie zna szczegółów implementacyjnych zewnętrznych warstw.

\vspace{0.5cm}
\noindent
\begin{minipage}[t]{0.4\textwidth}
    \vspace{0pt}
    \centering
    \includegraphics[width=\linewidth]{images/struktura_back_core.png} 
    \captionof{figure}{Str. .Core.}
\end{minipage}
\hfill
\begin{minipage}[t]{0.5\textwidth}
    \vspace{0pt}
    \justifying 
    \noindent
    W folderze Entities znajdują się główne encje, odpowiadające za przechowywanie danych. Enums zawiera wyliczenia, które definiują stałe wartości. W Abstractions znajdują się abstrakcyjne klasy, które są dziedziczone przez podobne encje. Dtos zawiera współdzielone obiekty zwracanych danych. Models przechowuje wspólne modele używane przez różne procesy. W Maps znajduje się logika mapowania danych w postaci słowników, który definiuje operacje pobierania i aktualizowania wartości w encjach.
\end{minipage}

\newpage

\noindent \textbf{Warstwa wspólna}\\
Moduł \texttt{chess.Shared} zawiera wspólne komponenty i funkcjonalności, które są wykorzystywane przez inne warstwy aplikacji. Celem tej warstwy jest centralizacja użytecznych elementów, które nie są specyficzne dla jednej warstwy, a są wykorzystywane przez różne części systemu. Dzięki temu wspólne elementy, takie jak wyjątki, middleware oraz konfiguracje, są łatwo dostępne. Warstwa ta pełni rolę wspierającą, zapewniając rozwiązania, które mogą być współdzielone przez inne warstwy aplikacji, co zwiększa spójność i ułatwia konserwację systemu.

\vspace{0.5cm}
\noindent
\begin{minipage}[t]{0.5\textwidth}
    \vspace{0pt}
    \justifying 
    \noindent
    Folder Exceptions przechowuje wyjątki, które pozwalają na precyzyjne zarządzanie błędami w systemie. Middleware zawiera komponent pośredniczący, które przechwytują i obsługują błędy HTTP. W folderze Options znajdują się rozszerzenia umożliwiające łatwe pobieranie konfiguracji z pliku \texttt{appsettings.json}.
\end{minipage}
\hfill
\begin{minipage}[t]{0.4\textwidth}
    \vspace{0pt}
    \centering
    \includegraphics[width=\linewidth]{images/struktura_back_shared.png} 
    \captionof{figure}{Str. .Shared.}
\end{minipage}
\vspace{0.5cm}

\noindent
Główne moduły projektu, są zintegrowane w aplikacji za pomocą klas rozszerzeń (Extensions). Te metody zapewniają wstrzyknięcie zależności oraz konfigurację wymaganych usług w projekcie, co pozwala na spójne i centralne zarządzanie konfiguracją każdego modułu. Każda z metod, wstrzykuje zależności specyficzne dla danej warstwy, po czym w głównej klasie Program następuje ich rejestracja. Plik ten odpowiada również za rejestracje niestandardowych komponentów, odpowiadają za dodanie specyficznych funkcji.

\vspace{0.5cm}
\begin{lstlisting}[language=CSharp]
builder.Services.AddShared();
builder.Services.AddApplication();
builder.Services.AddInfrastructure(builder.Configuration);
builder.Services.AddControllers();
builder.Services.AddCustomAuthorization();
builder.Services.AddCustomControllers();
builder.Services.AddMappingProfiles();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSignalR();
\end{lstlisting}

% \begin{figure}[h!]
%     \centering
%     \includegraphics[width=0.7\textwidth]{images/ex_add_services.png}
%     \caption{Fragment kodu: Przykład rejestracji serwisów w klasie Program.}
% \end{figure}

\newpage

\noindent \textbf{Warstwa testów integracyjnych}\\
Moduł \texttt{chess.Api.Tests} zawiera testy integracyjne dla kontrolerów API, zapewniając weryfikację poprawności działania interfejsu API w kontekście integracji z innymi komponentami systemu, takimi jak baza danych czy logika aplikacyjna. Testy te sprawdzają, czy odpowiedzi API są zgodne z oczekiwaniami, weryfikując m.in. poprawność danych wejściowych i wyjściowych oraz obsługę błędów. Każdy folder w tym module odpowiada pojedynczemu kontrolerowi API, umożliwiając modularne testowanie poszczególnych elementów aplikacji.

\vspace{0.5cm}
\noindent
\begin{minipage}[t]{0.4\textwidth}
    \vspace{0pt}
    \centering
    \includegraphics[width=\linewidth]{images/struktura_back_api_tests.png}
    \captionof{figure}{Str. .Api.Tests.}
\end{minipage}
\hfill
\begin{minipage}[t]{0.55\textwidth}
    \vspace{0pt}
    \justifying
    \noindent
    Warstwa ta zawiera testy integracyjne dla kontrolerów API. Każdy folder w tej warstwie odpowiada jednemu kontrolerowi API, umożliwiając modularne testowanie różnych części aplikacji. Testy wykorzystują narzędzia takie jak FluentAssertions i XUnit do tworzenia środowiska testowego. Dodatkowo główny folder zawiera kilka plików konfiguracyjnych potrzebnych do przeprowadzania testów.
\end{minipage}
\vspace{0.5cm}

\noindent \textbf{Warstwa testów logiki biznesowej}\\
Moduł \texttt{chess.Core.Tests} zawiera testy jednostkowe dla logiki biznesowej aplikacji. Testy te weryfikują poprawność działania poszczególnych komponentów wewnętrznych systemu, takich jak handlery żądań, serwisy, repozytoria oraz inne elementy logiki biznesowej. Dzięki tym testom możliwe jest zapewnienie, że logika aplikacji działa zgodnie z wymaganiami, niezależnie od zewnętrznych zależności.

\vspace{0.5cm}
\noindent
\begin{minipage}[t]{0.5\textwidth}
    \vspace{0pt}
    \justifying 
    \noindent
    Testy są podzielone na foldery odpowiadające poszczególnym kontrolerom, ze względu na podział żądań na cztery główne grupy. Każdy folder zawiera testy specyficzne dla wszystkich obsług żądań danego kontrolera.
\end{minipage}
\hfill
\begin{minipage}[t]{0.4\textwidth}
    \vspace{0pt}
    \centering
    \includegraphics[width=\linewidth]{images/struktura_back_core_tests.png} 
    \captionof{figure}{Str. .Core.Tests.}
\end{minipage}

\newpage

\subsubsection{REST API}

\noindent
Interfejsy API są najpopularniejszym sposobem interakcji programów i urządzeń w nowoczesnych technologiach obliczeniowych. API to zestaw reguł opisujących, jak jeden program może się łączyć oraz komunikować z innym. Jak sama nazwa wskazuje, API REST przekazuje na każde żądanie stan każdej transakcji, co daje korzyści związane z opracowaniem, wydajnością i zasobami w porównaniu do innych metod. REST rozwija się w ciągu ponad dwóch dekad i jest bardzo powszechnym podejściem do architektur opartych na usługach i architektur rozproszonych. \cite{OVHRestAPI}
\\\\
Zasób jest podstawowym pojęciem dla API REST. Zasób jest obiektem, który ma typ, powiązane dane, relacje z innymi zasobami i zestaw metod, które na nim działają. Jest bardzo podobny do idei obiektów w programowaniu, chociaż zdefiniowanych jest tylko kilka standardowych metod, typowych dla HTTP \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}}}, \textbf{\colorbox{green!90}{\textcolor{white}{POST}}}, \textbf{\colorbox{orange!90}{\textcolor{white}{PUT}}} i \textbf{\colorbox{red!90}{\textcolor{white}{DELETE}}}. Zasoby mogą istnieć same lub w zbiorach, które same są zasobami. 
\\\\

\noindent \textbf{Kontrolery API} \\
W systemie REST API zdefiniowane zostały cztery główne kontrolery, które odpowiadają za obsługę zapytań związanych z różnymi zasobami w aplikacji:

\begin{itemize}
    \item \textbf{UserController:}\\
    Odpowiada za zapytania związane z użytkownikami, takie jak rejestracja, logowanie, aktualizacja danych czy zarządzanie profilem.

    \item \textbf{FriendshipController"}\\
    Obsługuje zapytania dotyczące znajomości między użytkownikami, takie jak zapraszanie do znajomości, akceptowanie lub odrzucanie zaproszeń oraz zarządzanie relacjami.

    \item \textbf{WebGameController:}\\
    Zajmuje się zapytaniami dotyczącymi gier online pomiędzy użytkownikami, pozwalając na tworzenie, aktualizowanie i zarządzanie grami.

    \item \textbf{EngineGameController:}\\
    Odpowiada za zapytania związane z grami offline, które są rozgrywane z wykorzystaniem silnika szachowego, w tym rozpoczęcie gry, wykonywanie ruchów czy zmiana poziomu trudności.
\end{itemize}

\newpage

\noindent \textbf{Endpointy kontrolera UserController}
\begin{itemize} 
    \setlength\itemsep{0cm}
    \item \textbf{\colorbox{green!90}{\textcolor{white}{POST}} /api/user/sign-up} - Rejestruje użytkownika i wysyła kod weryfikacyjny e-mailem. 
    \item \textbf{\colorbox{green!90}{\textcolor{white}{POST}} /api/user/sign-in} - Loguje użytkownika i generuje token JWT. 
    \item \textbf{\colorbox{green!90}{\textcolor{white}{POST}} /api/user/regenerate-code} - Generuje nowy kod weryfikacyjny, usuwa stary, dla niezweryfikowanych użytkowników. 
    \item \textbf{\colorbox{orange!90}{\textcolor{white}{PUT}} /api/user/verify-email} - Weryfikuje adres e-mail użytkownika za pomocą dostarczonego kodu. 
    \item \textbf{\colorbox{orange!90}{\textcolor{white}{PUT}} /api/user/send-password-code} - Wysyła kod weryfikacyjny do odzyskania hasła. 
    \item \textbf{\colorbox{orange!90}{\textcolor{white}{PUT}} /api/user/reset-password} - Resetuje hasło użytkownika po podaniu kodu weryfikacyjnego. 
    \item \textbf{\colorbox{orange!90}{\textcolor{white}{PUT}} /api/user/change-password} - Zmienia hasło użytkownika, dostępne tylko dla użytkowników, którzy są zalogowani i zweryfikowani. 
    \item \textbf{\colorbox{orange!90}{\textcolor{white}{PUT}} /api/user/profile} - Aktualizuje dane profilu użytkownika. 
    \item \textbf{\colorbox{orange!90}{\textcolor{white}{PUT}} /api/user/data} - Zmienia dane użytkownika. 
    \item \textbf{\colorbox{orange!90}{\textcolor{white}{PUT}} /api/user/settings} - Zmienia ustawienia użytkownika, np. preferencje konta. 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/user} - Pobiera podstawowe informacje o użytkowniku. 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/user/full} - Pobiera pełne informacje o użytkowniku, takie jak historia, rankingi, szczegóły profilu. 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/user/{userId}/other} - Pobiera informacje o innym użytkowniku, np. publiczne dane profilu. 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/user/elo} - Pobiera informacje o rankingu Elo użytkownika. 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/user/is-verified} - Sprawdza, czy adres e-mail użytkownika jest zweryfikowany. 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/user/by-email} - Pobiera dane użytkownika na podstawie podanego adresu e-mail. 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/user/configuration} - Pobiera konfigurację rejestracji. 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/user/ranking} - Pobiera globalny ranking użytkowników. 
\end{itemize}

\newpage

\noindent  \textbf{Endpointy kontrolera FriendshipController}
\begin{itemize} 
    \setlength\itemsep{0cm}
    \item \textbf{\colorbox{green!90}{\textcolor{white}{POST}} /api/friendship/invite} - Tworzy zaproszenie do znajomości z oczekującym statusem. 
    \item \textbf{\colorbox{green!90}{\textcolor{white}{POST}} /api/friendship/block} - Tworzy zaproszenie do znajomości z odrzuconym statusem. 
    \item \textbf{\colorbox{orange!90}{\textcolor{white}{PUT}} /api/friendship/{friendshipId}/respond} - Zmienia status oczekującej znajomości (akceptacja lub odrzucenie zaproszenia). 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/friendship/all-by-status} - Pobiera wszystkich użytkowników z określonym statusem relacji (znajomi, oczekujący, zablokowani). 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/friendship/all-non} - Pobiera wszystkich użytkowników, którzy nie są w relacji z użytkownikiem. 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/friendship/{friendshipId}/profile} - Pobiera profil znajomego na podstawie identyfikatora znajomości. 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/friendship/ranking} - Pobiera ranking użytkowników wśród znajomych na podstawie wybranego modelu. 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/friendship/{friendshipId}/games} - Pobiera listę gier rozegranych w ramach znajomości. 
    \item \textbf{\colorbox{red!90}{\textcolor{white}{DELETE}} /api/friendship/{friendshipId}} - Usuwa znajomość lub odblokowuje użytkownika (w zależności od istniejącej relacji). 
\end{itemize}

\newpage

\noindent  \textbf{Endpointy kontrolera WebGameController}
\begin{itemize} 
    \setlength\itemsep{0cm}
    \item \textbf{\colorbox{green!90}{\textcolor{white}{POST}} /api/webgame/search} - Inicjuje poszukiwanie gry online, tworzy gracza i tworzy czas gry, jeśli takowy jeszcze nie istnieje. 
    \item \textbf{\colorbox{green!90}{\textcolor{white}{POST}} /api/webgame/private} - Tworzy prywatną grę. 
    \item \textbf{\colorbox{green!90}{\textcolor{white}{POST}} /api/webgame/email} - Tworzy prywatną grę przez podanie adresu e-mail przeciwnika 
    \item \textbf{\colorbox{green!90}{\textcolor{white}{POST}} /api/webgame/link} - Tworzy prywatną grę z linkiem, który umożliwia dostęp do gry.
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/webgame/is-in-game} - Sprawdza, czy gracz jest już w grze. 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/webgame/{gameId}/update-required} - Sprawdza, czy wymagana jest aktualizacja stanu gry dla gry wygenerowanej za pomocą linku. 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/webgame/{gameId}} - Pobiera pełne dane gry. 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/webgame/{gameId}/player} - Pobiera dane gracza. 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/webgame/{gameId}/time} - Pobiera czas pozostały dla gracza w danej grze. 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/webgame/{gameId}/opponent} - Pobiera dane przeciwnika z zakończonej gry. 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/webgame/{gameId}/timing} - Pobiera konfigurację czasu gry (timing) dla danej gry. 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/webgame/all-ongoing} - Pobiera wszystkie aktywne gry. 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/webgame/all-finished} - Pobiera wszystkie zakończone gry. 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/webgame/type-history} - Pobiera historię gier dla wybranego typu kontroli czasu gry. 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/webgame/invitations} - Pobiera wszystkie zaproszenia do gier. 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/webgame/{gameId}/messages} - Pobiera wszystkie wiadomości z danej gry. 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/webgame/stats} - Pobiera statystyki wszystkich gier rozegranych przez użytkownika. 
    \item \textbf{\colorbox{red!90}{\textcolor{white}{DELETE}} /api/webgame/abort} - Anuluje poszukiwanie gry online. 
    \item \textbf{\colorbox{red!90}{\textcolor{white}{DELETE}} /api/webgame/{gameId}/cancel} - Anuluje prywatną grę. Usuwa graczy. 
\end{itemize}

\newpage

\noindent  \textbf{Endpointy kontrolera EngineGameController}
\begin{itemize} 
    \setlength\itemsep{0cm}
    \item \textbf{\colorbox{green!90}{\textcolor{white}{POST}} /api/enginegame/start} - Rozpoczyna nową grę z silnikiem szachowym. 
    \item \textbf{\colorbox{green!90}{\textcolor{white}{POST}} /api/enginegame/{gameId}/make-move} - Wykonuje ruch w grze, wykonany przez gracza lub silnik.
    \item \textbf{\colorbox{orange!90}{\textcolor{white}{PUT}} /api/enginegame/{gameId}/end-game} - Kończy grę z silnikiem szachowym. 
    \item \textbf{\colorbox{orange!90}{\textcolor{white}{PUT}} /api/enginegame/{gameId}/change-engine} - Zmienia poziom trudności silnika szachowego. 
    \item \textbf{\colorbox{orange!90}{\textcolor{white}{PUT}} /api/enginegame/{gameId}/undo-move} - Cofnięcie ostatniego wykonanego ruchu. 
    \item \textbf{\colorbox{orange!90}{\textcolor{white}{PUT}} /api/enginegame/update-settings} - Aktualizuje ustawienia związane z grami z silnikiem szachowym. 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/enginegame/{gameId}} - Pobiera wszystkie dane dotyczące gry z silnikiem szachowym.
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/enginegame/{gameId}/winner} - Pobiera zwycięzcę gry z silnikiem szachowym. 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/enginegame/{gameId}/engine-move} - Pobiera ruch wykonany przez silnik w grze. 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/enginegame/{gameId}/all-messages} - Pobiera wszystkie wiadomości związane z aktualną grą z silnikiem. 
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /api/enginegame/all-games} - Pobiera wszystkie gry z silnikiem szachowym. 
\end{itemize}

\newpage

\noindent \textbf{Dokumentowanie API przy użyciu Swaggera}\\
Aby lepiej zilustrować strukturę i funkcjonalność REST API, poniżej przedstawiono przykład endpointów wygenerowanych automatycznie za pomocą biblioteki Swagger. Swagger umożliwia dokumentowanie API w sposób przejrzysty i interaktywny, co znacznie ułatwia zarówno tworzenie, jak i korzystanie z interfejsów API przez programistów.

\vspace{0.5cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{images/swagger_api.png}
    \caption{Przykład endpointów wygenerowanych za pomocą biblioteki Swagger.}
\end{figure}

\newpage

\subsubsection{SignalR}

\noindent
SignalR to biblioteka opracowana przez Microsoft, która umożliwia dodanie funkcji komunikacji w czasie rzeczywistym do aplikacji. Jest szczególnie przydatna w scenariuszach wymagających natychmiastowego przesyłania danych między serwerem a klientem, takich jak czaty, powiadomienia, aktualizacje w czasie rzeczywistym w aplikacjach finansowych, gier czy dashboardach. Główną zaletą SignalR jest ukrycie złożoności związanej z obsługą komunikacji w czasie rzeczywistym. Biblioteka automatycznie wybiera najlepszy dostępny mechanizm komunikacji w zależności od środowiska aplikacji, w tym:

\begin{itemize}
    \item \textbf{WebSockets} – preferowana metoda, jeśli jest obsługiwana przez przeglądarkę i serwer, zapewnia pełny duplex komunikacji.
    \item \textbf{Server-Sent Events} – alternatywa dla WebSockets, jednokierunkowa komunikacja serwera z klientem.
    \item \textbf{Long Polling} – metoda zastępcza, w której klient wysyła powtarzające się zapytania do serwera, oczekując odpowiedzi.
\end{itemize}

\noindent
SignalR opiera się na modelu hubów, które służą jako centralny punkt komunikacji. Klient i serwer mogą wysyłać wiadomości do huba, który z kolei przesyła je do odpowiednich odbiorców. Podstawowe kroki działania SignalR to:

\begin{itemize}
    \item Klient nawiązuje połączenie z serwerem za pomocą huba.
    \item Hub przekazuje wiadomości między serwerem a klientami.
    \item Klienci mogą nasłuchiwać na określone metody w hubie.
    \item Serwer może w dowolnym momencie wysyłać wiadomości do klientów.
\end{itemize}

\noindent
W aplikacji utworzono jedną klasę huba, która odpowiada za obsługę gier online. Klasa ta centralizuje komunikację między klientami a serwerem, umożliwiając natychmiastowe przesyłanie danych, takich jak ruchy w grze czy informacje o stanie gry. Dodatkowo zaimplementowano interfejs, który definiuje metody wywoływane przez odpowiednich klientów. Interfejs ten pełni rolę kontraktu, gwarantując, że klienci będą mieli dostęp do spójnych metod obsługi gier online. Dzięki temu różne typy klientów mogą w prosty sposób integrować się z hubem i korzystać z jego funkcji, takich jak wysyłanie ruchu, odbieranie powiadomień czy synchronizacja danych.
\\\\
Na następnej stronie przedstawiono szczegółowy opis metod dostępnych w ramach interfejsu SignalR, z podziałem na typy zapytań.

\newpage

\begin{itemize}
    \setlength\itemsep{0cm}
    \item \textbf{\colorbox{green!90}{\textcolor{white}{POST}} /game-hub/add-self-notification} - Dodaje użytkownika do grupy powiadomień, umożliwiając odbieranie powiadomień.
    \item \textbf{\colorbox{green!90}{\textcolor{white}{POST}} /game-hub/add-player} - Dodaje użytkownika do grupy gry i wysyła żądanie weryfikacji dostępu.
    \item \textbf{\colorbox{green!90}{\textcolor{white}{POST}} /game-hub/player-joined} - Dodaje użytkownika do kolejki gry / rozpoczyna gry online.
    \item \textbf{\colorbox{green!90}{\textcolor{white}{POST}} /game-hub/rematch} - Tworzy nową grę dla dwóch tych samych graczy, którzy już rozegrali jedną partię.
    \item \textbf{\colorbox{green!90}{\textcolor{white}{POST}} /game-hub/make-move} - Wykonuje ruch w grze, aktualizuje stan.
    \item \textbf{\colorbox{green!90}{\textcolor{white}{POST}} /game-hub/send-player-message} - Wysyła wiadomość graczowi w ramach bieżącej gry.
    \item \textbf{\colorbox{green!90}{\textcolor{white}{POST}} /game-hub/send-game-message} - Wysyła wiadomość w grze dla wszystkich graczy.
    \item \textbf{\colorbox{green!90}{\textcolor{white}{POST}} /game-hub/send-draw-message} - Wysyła propozycję remisu.
    \item \textbf{\colorbox{orange!90}{\textcolor{white}{PUT}} /game-hub/end-game} - Kończy grę, aktualizuje stan gry.
    \item \textbf{\colorbox{orange!90}{\textcolor{white}{PUT}} /game-hub/accept-rematch} - Akceptuje propozycję rewanżu, powiadamia obu graczy i rozpoczyna grę.
    \item \textbf{\colorbox{orange!90}{\textcolor{white}{PUT}} /game-hub/accept-invitation} - Akceptuje zaproszenie do gry, powiadamia graczy i rozpoczyna grę.
    \item \textbf{\colorbox{orange!90}{\textcolor{white}{PUT}} /game-hub/update-private-game} - Aktualizuje prywatną grę utworzoną przez link.
    \item \textbf{\colorbox{orange!90}{\textcolor{white}{PUT}} /game-hub/typing-status} - Aktualizuje status pisania użytkownika.
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /game-hub/get-winner} - Pobiera dane zwycięzcy gry.
    \item \textbf{\colorbox{cyan!90}{\textcolor{white}{GET}} /game-hub/notify-user} - Dostarcza dane niezbędne zaproszonemu użytkownikowi do zaakceptowania gry.
    \item \textbf{\colorbox{red!90}{\textcolor{white}{DELETE}} /game-hub/player-leaved} - Usuwa gracza z kolejki gry.
    \item \textbf{\colorbox{red!90}{\textcolor{white}{DELETE}} /game-hub/leave-game} - Usuwa połączenie z grą.
    \item \textbf{\colorbox{red!90}{\textcolor{white}{DELETE}} /game-hub/decline-invitation} - Odrzuca zaproszenie do gry i powiadamia zapraszającego.
    \item \textbf{\colorbox{red!90}{\textcolor{white}{DELETE}} /game-hub/remove-draw} - Odrzuca propozycję remisu.
    \item \textbf{\colorbox{red!90}{\textcolor{white}{DELETE}} /game-hub/cancel-rematch} - Anuluje ofertę rewanżu w grze.
\end{itemize}

\newpage

\noindent \textbf{Metody po stronie klienta}
Interfejs \texttt{IGameHub} definiuje zestaw metod, które są dostępne do wywołania przez klienta, po otrzymaniu powiadomienia z serwera. Poniżej wypisano metody zadeklarowane w interfejsie:

\begin{itemize}
    \item \textbf{GamesChanged} \\
    Powiadamia grupę w kolejce o nowych grach, zazwyczaj po ich utworzeniu.
    \item \textbf{GameUpdated} \\
    Informuje uczestników gry o wykonanym ruchu
    \item \textbf{GameEnded} \\
    Powiadamia użytkowników o zakończeniu gry.
    \item \textbf{InvitedToGame} \\
    Wysyła zaproszenie do gry, powiadamiając zaproszoną osobę o szczegółach gry.
    \item \textbf{GameAccepted} \\
    Informuje użytkowników o zaakceptowaniu zaproszenia do gry i rozpoczęciu gry.
    \item \textbf{MessagesUpdated} \\
    Powiadamia o nowych wiadomościach wysłanych w grze.
    \item \textbf{InvitationDeclined} \\
    Powiadamia o odrzuceniu zaproszenia do gry.
    \item \textbf{TypingStatus} \\
    Powiadamia o stanie pisania w grze, informując, czy użytkownik pisze wiadomość.
    \item \textbf{RematchRequested} \\
    Informuje o ofercie rewanżu, gdy druga osoba zaproponuje powtórkę gry.
    \item \textbf{RematchCanceled} \\
    Powiadamia o anulowaniu oferty rewanżu.
    \item \textbf{GetWinner} \\
    Pozwala uzyskać informację o zwycięzcy zakończonej gry.
\end{itemize}

\newpage

\subsubsection{Komunikacja z silnikiem}

\begin{minipage}[t]{0.2\textwidth} 
    \vspace{0pt} 
    \centering
    \includegraphics[width=\linewidth]{images/stockfish_logo.png} 
\end{minipage} 
\hfill 
\begin{minipage}[t]{0.7\textwidth} 
    \vspace{0pt} 
    \justifying 
    \noindent 
    Silnik szachowy \texttt{Stockfish} jest jednym z najpotężniejszych i najczęściej używanych silników szachowych na świecie. Jest to oprogramowanie typu open-source, które zostało utworzone, aby oferować najwyższą możliwą siłę obliczeniową w grach szachowych. Stockfish jest napisany w języku \texttt{C++} i jest dostępny na wielu platformach.
\end{minipage} 
\vspace{1cm}

\noindent
Stockfish jest oparty na algorytmie minimax, który jest popularnym podejściem w sztucznej inteligencji do podejmowania decyzji w grach dwuosobowych, takich jak szachy. Algorytm ten stara się ocenić każde możliwe posunięcie, wybierając to, które zapewnia najlepszy wynik, bazując na analizie możliwych przyszłych ruchów. Używa on także heurystyk oraz analizy pozycyjnej, aby ocenić siłę danej pozycji na szachownicy. Co więcej, Stockfish jest w stanie analizować partie z dużą prędkością, co czyni go idealnym narzędziem do analizy gier na różnych poziomach zaawansowania.
\\\\
Jednym z kluczowych aspektów silnika Stockfish jest jego zdolność do pracy w ramach protokołu UCI (Universal Chess Interface). UCI jest standardem, który umożliwia komunikację między silnikiem szachowym a różnymi interfejsami graficznymi (GUI), pozwalając na łatwą integrację z aplikacjami szachowymi. Dzięki temu użytkownicy mogą korzystać z graficznych interfejsów, takich jak Arena, Fritz czy lichess, aby bezpośrednio połączyć się z silnikiem Stockfish, wybierając odpowiednią wersję i parametry.
\\\\
Silnik Stockfish jest również wykorzystywany do tworzenia testów i analiz w wielu aplikacjach szachowych, zarówno komercyjnych, jak i akademickich. Dzięki swojej mocy obliczeniowej, dokładności i dostępności, Stockfish stał się nieocenionym narzędziem w wielu dziedzinach związanych z szachami, od profesjonalnych gier po badania naukowe.
\\\\
W kontekście komunikacji z silnikiem Stockfish, aplikacja korzysta z interfejsu UCI, wysyłając zapytania w postaci komend tekstowych do silnika, który następnie odpowiada, udzielając wskazówek dotyczących najlepszych posunięć, oceniając pozycje lub generując pełną analizę partii. UCI zapewnia, że aplikacja może zarządzać różnymi funkcjami silnika, jak generowanie ruchów, ustawienie poziomu trudności czy analiza pozycji na szachownicy.

\newpage

\noindent
Komunikacja z silnikiem szachowym jest kluczowym elementem w budowie aplikacji. W projekcie wykorzystano klasę \texttt{EngineService}, która zapewnia funkcjonalność umożliwiającą połączenie z procesem silnika. Sam silnik działa jako aplikacja uruchamiana w tle na serwerze, co pozwala na obsługę wielu równoczesnych zapytań.
\\\\
Klasa ta implementuje interfejs \texttt{IEngineService}, co zapewnia jednolitość i ułatwia integrację z innymi komponentami aplikacji. W konstruktorze tej klasy tworzony jest obiekt typu \texttt{Process}, który uruchamia silnik szachowy.

\begin{itemize} 
    \item \textbf{Startowanie procesu silnika:} W konstruktorze klasy, obiekt typu \texttt{Process} jest konfigurowany za pomocą klasy \texttt{ProcessStartInfo}. Ustawienia te zapewniają, że silnik będzie działał w tle bez interakcji z interfejsem użytkownika, a komunikacja będzie odbywała się za pomocą strumieni wejścia i wyjścia. 
    \item \textbf{Wysyłanie komend do silnika:} Metoda \texttt{SendCommand} pozwala na wysyłanie komend do silnika. Komendy są przesyłane do standardowego wejścia silnika, a następnie natychmiastowo zapisywane do strumienia wyjściowego. 
    \item \textbf{Odczytywanie wyników:} Metoda \texttt{ReadOutput} służy do odczytywania danych wyjściowych z silnika. Wykorzystuje ona strumień wyjściowy, by zbierać linie tekstu, które są następnie przechowywane w liście. Proces odczytu jest ograniczony czasowo, co zapobiega zablokowaniu aplikacji w przypadku długotrwałych odpowiedzi. 
    \item \textbf{Zamykanie procesu:} Metoda \texttt{Close} wysyła do silnika komendę \texttt{quit} a następnie zamyka proces, kończąc w ten sposób interakcję z silnikiem. 
\end{itemize}


\noindent \textbf{Wykorzystanie serwisu}\\
Implementacja interesu serwisu \texttt{IEngineService} jest wykorzystywany w jednym z handlerów, służącym do zarządzania interakcją z silnikiem szachowym, który oblicza najlepszy ruch w grze na podstawie aktualnej pozycji. Handler ten pełni rolę pośrednika pomiędzy aplikacją a silnikiem, umożliwiając pobieranie ruchów zaproponowanych przez silnik.
\\\\
Na następnej stronie przedstawiono wykorzystanie serwisu komunikacji z silnikiem, na przykładzie obsługi zapytań związanych z wykonywaniem ruchów w grach offline.

\newpage

\begin{enumerate}
    \item \textbf{Inicjalizacja serwisu}\\
    W konstruktorze handlera przyjmowane są zależności. Dzięki temu handler ma dostęp do metod serwisu, które są kluczowe do interakcji z silnikiem.

    \item \textbf{Przygotowanie do obliczeń}\\
    Po pobraniu gry na podstawie identyfikatora (ID) i walidacji dostępu użytkownika, handler tworzy pełną wersję pozycji szachowej w formacie FEN. Zapis pozycji jest następnie przesyłany do silnika szachowego za pomocą metody \texttt{SendCommand}.

    \item \textbf{Wykonanie obliczeń przez silnik}\\
    Kiedy silnik otrzyma polecenie z pełnym zapisem FEN, handler wysyła kolejną komendę do silnika za pomocą \texttt{SendCommand}, prosząc o wykonanie ruchu na określoną głębokość analizy na podstawie ustawionego poziomu trudności. Serwis przesyła tę komendę do silnika, który następnie analizuje pozycję i oblicza najlepszy możliwy ruch.

    % \begin{figure}[h!]
    %     \centering
    %     \includegraphics[width=0.7\textwidth]{images/ex_send_command.png}
    %     \caption{Fragment kodu - przesył zapytania do silnika.}
    % \end{figure}

\begin{lstlisting}[language=CSharp]
_engineService.SendCommand($"position fen {fullFen}");
_engineService.SendCommand($"go depth {game.Level}");
\end{lstlisting}

    \item \textbf{Odczyt odpowiedzi od silnika}\\
    Po wysłaniu komendy, handler oczekuje na odpowiedź od silnika. Metoda \texttt{ReadOutput} serwisu jest używana do odczytywania odpowiedzi, która zawiera najlepszy ruch. Odpowiedź ta jest przetwarzana w pętli, aż silnik zwróci ruch lub upłynie czas oczekiwania.

    \item \textbf{Przetwarzanie najlepszego ruchu}\\
    Po uzyskaniu najlepszego ruchu z silnika, handler konstruuje nową wersję FEN, która reprezentuje pozycję po wykonaniu ruchu. Następnie wysyła kolejne komendy do silnika, aby zaktualizować pozycję w silniku i zwrócić nowe dane.

    \item \textbf{Zakończenie interakcji}\\
    Po zakończeniu obliczeń i uzyskaniu wyników, serwis jest zamykany za pomocą metody \texttt{\textbf{Close}}. To zapewnia, że proces silnika jest zakończony, a wszystkie zasoby systemowe są odpowiednio zwolnione.
\end{enumerate}

\newpage

\subsubsection{Kluczowe mechanizmy gry}

\noindent \textbf{Tworzenie i dołączanie do gier}\\
Proces tworzenia i dołączania do gier w aplikacji można podzielić na trzy główne typy: gry online z losowym graczem, prywatne gry online oraz gry z komputerem. Każdy z tych typów ma swoją specyficzną logikę, która determinuje sposób, w jaki gracze dołączają do gier oraz jak te są one inicjowane.

\begin{itemize}
    \item \textbf{Gry online z losowym graczem}\\
    Użytkownik rozpoczyna proces poszukiwania gry, co skutkuje utworzeniem rekordu gracza w systemie i trafieniem do kolejki oczekujących. Gra jest tworzona, gdy dołączają inni gracze i system sprawdza, czy warunki do rozpoczęcia gry zostały spełnione, np. znalezienie przeciwnika o zbliżonej punktacji. Po spełnieniu warunków, gra zostaje utworzona, a gracze automatycznie rozpoczynają rozgrywkę.
    
    \item \textbf{Prywatne gry online}\\
    Prywatne gry różnią się od gier z losowym przeciwnikiem tym, że są tworzone przez jednego użytkownika, który zaprasza drugiego do wspólnej gry. Gracze są przypisani do gry bez oczekiwania w kolejce. Prywatne gry mają tę specyficzną cechę, że gracze w takich grach są oznaczani jako "prywatni" i nie biorą udziału w systemie losowego dobierania graczy, co oznacza, że ich gra odbywa się tylko z zaproszonymi osobami.

    \item \textbf{Gry z komputerem}\\
    W grach z komputerem proces jest w pełni zautomatyzowany. Użytkownik gra przeciwko sztucznej inteligencji, a gra jest tworzona automatycznie. Nie wymaga oczekiwania na innych graczy, ponieważ użytkownik jest jedynym uczestnikiem, a jego przeciwnikiem jest komputerowy oponent.

\end{itemize}

\noindent \textbf{Powiadomienia o zmianach stanu kolejki}\\
Aby zapewnić synchronizację pomiędzy graczami i ich reakcję na zmiany stanu kolejki, aplikacja wykorzystuje technologię SignalR. To narzędzie, które pozwala na natychmiastową synchronizację stanu gry pomiędzy graczami, zapewniając, że każdy gracz jest na bieżąco informowany o tym, czy został dołączony do gry, lub czy otrzymał zaproszenie do prywatnej gry. Dzięki tej bibliotece gracze mogą otrzymywać powiadomienia w czasie rzeczywistym, co umożliwia im płynne przejście do etapu gry bez opóźnień.

\newpage

\noindent \textbf{Punktacja ELO}\\
Punktacja ELO to system oceny umiejętności graczy stosowany w aplikacji do określania ich relatywnej siły gry. Mechanizm ten jest dynamiczny, co oznacza, że po każdej zakończonej grze punkty ELO obu graczy są aktualizowane w zależności od wyniku rozgrywki. Wartość zmiany w punktacji jest obliczana na podstawie różnicy punktów między graczami oraz wyniku gry. System uwzględnia pięć kategorii czasowych rozgrywek, z których każda ma osobną punktację. Do obliczenie punktacji rozróżnia się trzy główne przypadki:

\begin{itemize}
    \item \textbf{Wygrana lepszego gracza}\\
    Jeśli zwycięzcą gry jest gracz, który przed rozgrywką miał wyższą punktację ELO niż jego przeciwnik, oznacza to, że wynik był bardziej przewidywalny. W takim przypadku zmiana punktacji dla zwycięzcy oraz przegranego jest stosunkowo niewielka, ponieważ potwierdza ona wcześniejsze przypuszczenia o różnicy w umiejętnościach graczy.

    \[ \text{elo}_{\pm} = \lceil \frac{100}{0.1 \cdot \Delta \text{elo} + 10} \rceil \]

    Gdzie $ \text{elo}_{\pm} $ oznacza punkty dodane / odjęte graczom a $ \Delta \text{elo} $ oznacza różnice w punktacji pomiędzy graczami przez rozpoczęciem gry. Im większa różnica w punktacji ELO między graczami, tym mniejsza zmiana punktów dla zwycięzcy, co odzwierciedla mniejsze znaczenie wygranej dla wyżej punktowanego gracza.

    \item \textbf{Wygrana słabszego gracza}\\
    Jeśli zwycięzcą gry jest gracz z niższą punktacją ELO niż jego przeciwnik, wynik jest bardziej zaskakujący, co prowadzi do większych zmian punktacji. W takim przypadku stosuje się wzór:

    \[ \text{elo}_{\pm} = \lceil 0.1 \cdot \Delta \text{elo} + 10 \rceil \]

    Gdzie $ \text{elo}_{\pm} $ oznacza punkty dodane / odjęte graczom a $ \Delta \text{elo} $ oznacza różnice w punktacji pomiędzy graczami przez rozpoczęciem gry. W tym przypadku, większa różnica punktów ELO działa na korzyść zwycięzcy, co skutkuje znaczącym wzrostem jego punktacji. Analogicznie, przegrany, który był wyżej punktowany, traci więcej punktów, co odzwierciedla większą wagę niespodziewanego wyniku.

\newpage

    \item \textbf{Przypadek remisu}\\
    Remis jest traktowany jako sytuacja, w której obaj gracze osiągają równy wynik, co skutkuje mniejszą zmianą punktacji niż w przypadku zwycięstwa jednego z graczy. Zmiana punktacji w przypadku remisu zależy również od różnicy punktów między graczami. Stosowany jest wzór:

    \[ \text{elo}_{\pm} = \lceil 0.05 \cdot \Delta \text{elo} \rceil \]

    Gdzie $ \text{elo}_{\pm} $ oznacza punkty dodane / odjęte graczom a $ \Delta \text{elo} $ oznacza różnice w punktacji pomiędzy graczami przez rozpoczęciem gry.     W tym przypadku gracz z wyższą punktacją traci punkty, natomiast gracz z niższą zyskuje je, ponieważ remis z bardziej doświadczonym przeciwnikiem jest przegranego korzystnym rezultatem.

\end{itemize}

\noindent
Poniższy wykres ilustruje zależność zmiany punktacji ELO, gdzie $ \text{y} = \text{elo}_{\pm} $ od różnicy punktacji między graczami $ \text{x} = \Delta \text{elo} $  w trzech wyżej wymienionych scenariuszach. Każda z tych sytuacji jest modelowana za pomocą odpowiedniej funkcji, co pozwala zobaczyć, jak zmieniają się wartości punktów dodawanych lub odejmowanych w zależności od poziomu graczy.

\vspace{0.5cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{images/graf_elo_calc.png}
    \caption{Wykres przedstawia zmiane punktacji ELO w zależności od różnicy poziomu graczy. Wykresy utworzone za pomocą strony www.desmos.com}
\end{figure}
\vspace{0.5cm}

\newpage

\noindent \textbf{Zarządzanie czasem gry}\\
W szachach istnieje kilka różnych typów ustawienia czasu, które mają wpływ na dynamikę gry. W zależności od wybranego typu, gracze mają różne limity czasowe na wykonanie swoich ruchów. Każdy z tych typów jest dostosowany do innego tempa rozgrywki, co pozwala na dopasowanie doświadczenia gry do preferencji graczy. Czas gry w szachach może obejmować różne długości, poczynając od błyskawicznych partii typu \texttt{Bullet}, po długoterminowe gry \texttt{Daily}.
\\\\
Poniżej przedstawiona jest tabela pokazująca różne kategorie kontroli czasowych:

\renewcommand{\arraystretch}{1.2}
\begin{table}[h!]
    \centering
    \begin{tabular}{|l|m{3cm}|m{3cm}|m{5cm}|}
        \hline
        \rowcolor{lightgray}
        \textbf{Typ Czasu} & \textbf{Zakres Czasu} & \textbf{Inkrement} & \textbf{Charakterystyka} \\ \hline
        \textbf{Bullet} & 1 - 3 min. & 0 - 60 sek. & Bardzo szybka gra. \\ \hline
        \textbf{Blitz} & 3 - 10 min. & 0 - 60 sek. & Gra o szybkim tempie. \\ \hline
        \textbf{Rapid} & 10 - 60 min. & 0 - 60 sek. & Standardowe tempo. \\ \hline
        \textbf{Classic} & 60 - 1440 min. & brak & Gry dzienne. \\ \hline
        \textbf{Daily} & $\geq$ 1440 min. & brak & Gry kilkudniowe. \\ \hline
    \end{tabular}
    \caption{Rodzaje kontroli czasowej gry.}
\end{table}
\vspace{0.5cm}

\noindent
Podczas pierwszego pobrania gry przez graczy ustalany jest czas rozpoczęcia partii. Następnie, przy każdym wykonanym ruchu, system oblicza, ile czasu minęło od ostatniego zarejestrowanego momentu (czy to od rozpoczęcia gry, czy od ostatniego ruchu). Na podstawie tej różnicy czasu, system aktualizuje pozostały czas dla gracza, odejmując upływający czas od jego pozostałego limitu. Dodatkowo, po każdym ruchu do czasu pozostałego dla gracza dodawany jest inkrement. Czas jest aktualizowany osobno dla każdego z graczy, w zależności od tego, która tura jest aktualnie wykonywana.

% \vspace{0.5cm}
% \begin{figure}[h!]
%     \centering
%     \includegraphics[width=0.7\textwidth]{images/ex_update_times.png}
%     \caption{Fragment kodu: Aktualizacje czasu graczy.}
% \end{figure}
% \vspace{0.5cm}

\newpage

\subsubsection{Pozostałe kluczowe aspekty}

\noindent \textbf{Przetwarzanie zapytań}\\
W systemie przetwarzania zapytań wykorzystywana jest biblioteka MediatR, która umożliwia zarządzanie zapytaniami w sposób przejrzysty i modularny. MediatR opiera się na wzorcu projektowym Mediatora, co pozwala na oddzielenie logiki przetwarzania zapytań od innych komponentów aplikacji.
\\\\
W tym systemie każde zapytanie, pobrania danych lub zapisania ich, jest reprezentowane przez obiekt, który dziedziczy po interfejsie \texttt{IRequest<T>}, gdzie \texttt{T} oznacza typ odpowiedzi, którą zapytanie zwróci. Zapytania te są przekazywane do mediatorów, którzy następnie kierują je do odpowiednich handlerów, czyli klas odpowiedzialnych za wykonanie logiki związanej z zapytaniem.
\\\\

\noindent \textbf{Przebieg przetwarzania zapytania}
\begin{enumerate}
    \item \textbf{Zgłoszenie zapytania:} Kiedy klient wyśle zapytanie do systemu przez API lub SignalR, zapytanie to jest mapowane na odpowiedni \texttt{Request}, który może zawierać dane wejściowe potrzebne do przetworzenia.
    \item \textbf{Przetwarzanie zapytania:} Zapytanie trafia do MediatR, który przekazuje je do odpowiedniego handlera. Handler jest odpowiedzialny za wykonanie logiki biznesowej.
    \item \textbf{Wykonanie akcji:} Handler wykonuje określoną akcję. Może to być np. zapis do bazy danych, obliczenie wyniku gry, aktualizacja punktacji ELO lub inne działania biznesowe.
    \item \textbf{Zwrócenie odpowiedzi:} Po wykonaniu akcji, handler zwraca odpowiedź (np. dane w formie obiektu, kod statusu, wynik operacji). MediatR przekazuje tę odpowiedź z powrotem do klienta.
\end{enumerate}

\noindent
W systemie, który obsługuje zapytania, każde zapytanie jest reprezentowane przez osobny obiekt zapytania, który jest mapowany na żądanie. Każdy \texttt{Request} posiada przypisany handler, który odpowiedzialny jest za realizację zapytania.

\newpage

\noindent
Proces przetwarzania zapytania w systemie został szczegółowo przedstawiony na poniższym diagramie. Ukazuje on pełny przepływ danych, rozpoczynając od wysłania żądania HTTP przez klienta. Następnie żądanie jest odbierane przez odpowiedni punkt końcowy API lub metodę Huba SignalR, który przetwarza przesłany model danych. Model ten jest mapowany na obiekt zapytania (Request), który definiuje szczegóły operacji do wykonania. Zapytanie trafia do handlera, który obsługuje żądanie i wykonuje określoną logikę biznesową. W przypadku konieczności dostępu do danych, handler korzysta z repozytorium, które odpowiada za interakcję z bazą danych. Dane pobrane w formie encji są następnie mapowane na obiekt DTO (Data Transfer Object), który stanowi zwracany wynik. Finalnie odpowiedź w postaci DTO jest zwracana przez punkt końcowy API do klienta, który otrzymuje wynik operacji w formacie zgodnym z jego wymaganiami. Diagram ten ilustruje całość procesu, demonstrując jego spójność.

\vspace{0.5cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{images/diagram_back.png}
    \caption{Diagram przedstawiający proces przetwarzania zapytania na serwerze. Opracowany za pomocą aplikacji Viso.}
\end{figure}

\newpage

\noindent \textbf{Rezultaty zapytań i paginacja}\\

W systemie zwracane są odpowiedzi zawierające dane w różnych formach. W przypadku zapytań związanych z wyszukiwaniem lub dużymi zbiorami danych, używa się specjalnych klas do mapowania wyników na modele. Część zapytań zwraca dane w postaci DTO (Data Transfer Object), które są prostymi obiektami przechowującymi dane, mapowanymi z encji bazy danych, co ułatwia przekazywanie danych między warstwami aplikacji.
\\\\
W przypadku zapytań dotyczących wielu elementów stosowana jest paginacja, która dzieli dane na mniejsze części, poprawiając wydajność i doświadczenie użytkownika. Zamiast przesyłać wszystkie dane naraz, system zwraca tylko określoną liczbę elementów na stronie oraz numer strony. Dzięki temu użytkownik może efektywnie nawigować po wynikach, ładować tylko potrzebne dane i nie obciążać systemu. W systemie zaimplementowane są dwie klasy wspierające paginację:

\begin{itemize}
    \item \textbf{PagedRequest:} Ogólna klasa, z której dziedziczą modele i zapytania wymagające paginacji.
    \item \textbf{PagedResult:} Klasa, która jest używana do zwracania wyników zapytania z paginacją. Przyjmuje generyczny typ T, który odpowiada za dane zwracane w odpowiedzi. Zawiera szczegóły dotyczące wyników.
\end{itemize}

% \begin{figure}[h!]
%     \centering
%     \includegraphics[width=0.7\textwidth]{images/ex_pagination.png}
%     \caption{Fragment kodu: Klasa rezultatu paginacji.}
% \end{figure}

\begin{lstlisting}[language=CSharp]
public PagedResult(List<T> items, int totalCount, int pageSize, int pageNumber) {
    Items = items
        .Skip(pageSize * (pageNumber - 1))
        .Take(pageSize)
        .ToList();

    TotalItemsCount = totalCount;
    ItemsFrom = pageSize * (pageNumber - 1) + 1;
    int itemsTo = pageSize * (pageNumber - 1) + pageSize;
    ItemsTo = itemsTo > totalCount ? totalCount : itemsTo;
    TotalPages = (int)Math.Ceiling(totalCount / (double)pageSize);
}
\end{lstlisting}

\newpage

% \noindent
% Poniższe ilustracje przedstawiają strukturę modelu używanego w systemie. Po lewej stronie znajduje się definicja modelu w TypeScript, wykorzystywana po stronie klienta, natomiast po prawej widoczny jest odpowiednik tego modelu w kodzie zaplecza, który reprezentuje dane w aplikacji po stronie serwera.

% \vspace{0.5cm}
% \begin{minipage}[t]{0.45\textwidth} 
%     \vspace{0pt} 
%     \centering 
%     \includegraphics[width=\linewidth]{images/ex_model_front.png} 
%     \captionof{figure}{Fragment kodu: Przykład modelu danych klienta}
% \end{minipage} 
% \hfill 
% \begin{minipage}[t]{0.45\textwidth} 
%     \vspace{0pt} 
%     \centering 
%     \includegraphics[width=\linewidth]{images/ex_model_back.png} 
%     \captionof{figure}{Fragment kodu: Przykład modelu danych serwera}
% \end{minipage} 
% \vspace{0.5cm}

% \noindent
% Rysunek poniżej przedstawia strukturę obiektu żądania. Obiekt ten przenosi dane wejściowe od punktu końcowego API do handlera, który wykonuje logikę biznesową.

% \vspace{0.5cm}
% \begin{figure}[h!]
%     \centering
%     \includegraphics[width=1\textwidth]{images/ex_request_back.png}
%     \caption{Fragment kodu: Struktura obiektu żądania (Request)}
% \end{figure}
% \vspace{0.5cm}

% \noindent
% Kolejne diagramy ilustrują przykładowe obiekty DTO. Po lewej stronie widoczny jest obiekt używany w warstwie zaplecza, który mapuje dane encji pobrane z bazy. Po prawej znajduje się odpowiedni typ w TypeScript, który reprezentuje te dane po stronie klienta.

% \vspace{0.5cm}
% \begin{minipage}[t]{0.45\textwidth} 
%     \vspace{0pt} 
%     \centering 
%     \includegraphics[width=\linewidth]{images/ex_dto_back.png} 
%     \captionof{figure}{Fragment kodu: DTO w warstwie serwerowej}
% \end{minipage} 
% \hfill 
% \begin{minipage}[t]{0.45\textwidth} 
%     \vspace{0pt} 
%     \centering 
%     \includegraphics[width=\linewidth]{images/ex_dto_front.png} 
%     \captionof{figure}{Fragment kodu: DTO w warstwie klienta}
% \end{minipage}

% \newpage

\noindent \textbf{Serwis SMTP}\\
Serwis SMTP (Simple Mail Transfer Protocol) jest wykorzystywany w aplikacji do obsługi wysyłania wiadomości e-mail, co obejmuje zarówno proces weryfikacji e-maila użytkowników, jak i powiadomień dotyczących gier. W aplikacji implementacja serwisu SMTP umożliwia automatyczne generowanie i wysyłanie e-maili w różnych scenariuszach.
\\\\
Serwis SMTP, za pomocą klasy SmtpService, korzysta z biblioteki .NET, która umożliwia konfigurację połączeń z serwerem pocztowym i wysyłanie e-maili. Serwis ten jest skonfigurowany przy użyciu opcji zawartych w appsettings.json, który przechowuje dane potrzebne do połączenia z serwerem SMTP.
\\\\
Serwis implementuje kilka kluczowych metod umożliwiających wysyłkę maili, służących do weryfikacji lub otrzymywania powiadomień. Wszystkie metody w serwisie tworzą wiadomość e-mail, której treść jest zbudowana w formacie HTML, co umożliwia bardziej zaawansowane formatowanie, w tym wstawianie obrazków, linków czy kodów.
\\\\
Wszystkie e-maile są wysyłane przez SmtpClient, który łączy się z odpowiednim serwerem SMTP i wysyła wiadomość do wskazanego odbiorcy. Dzięki asynchroniczności operacji, wysyłanie e-maili nie blokuje głównego wątku aplikacji, co zapewnia płynność działania systemu.
\\\\

\noindent \textbf{Serwis JWT}\\
Serwis JWT (JSON Web Token) w aplikacji służy do generowania tokenów autoryzacyjnych, które są wykorzystywane do uwierzytelniania użytkowników oraz zapewnienia dostępu do chronionych zasobów aplikacji. Tokeny JWT są powszechnie stosowane w aplikacjach webowych do obsługi logowania i autoryzacji, a ich głównym celem jest umożliwienie użytkownikowi dostępu do określonych zasobów, bez konieczności ponownego wprowadzania danych logowania przy każdym żądaniu.
\\\\
Implementacja serwisu JWT w aplikacji opiera się na klasie, która zawiera jedną metodę - \texttt{GetJwtToken}. Metoda ta przyjmuje obiekt \texttt{User}, który reprezentuje zalogowanego użytkownika, a na podstawie jego danych generuje unikalny token. Serwis ten generuje tokeny uwierzytelniające użytkowników. Token jest serializowany do formatu string i przesyłany w odpowiedzi do klienta.


\newpage

\noindent \textbf{Entity Framework}\\
Entity Framework (EF) to nowoczesny framework ORM (Object-Relational Mapping) opracowany przez Microsoft, który umożliwia programistom łatwe mapowanie struktur danych obiektowych na tabele relacyjnej bazy danych. W aplikacji wykorzystuje się EF do zarządzania danymi oraz interakcji z bazą danych PostgreSQL w sposób obiektowy. Dzięki EF operacje na danych stają się prostsze i bardziej czytelne, eliminując potrzebę pisania ręcznych zapytań SQL.
\\\\
Podstawą działania EF jest klasa kontekstu, która w aplikacji została zaimplementowana jako \texttt{ChessAppDbContext : DbContext}. Kontekst bazy danych zarządza połączeniem z bazą danych oraz umożliwia wykonywanie operacji CRUD na encjach. W aplikacji konfiguracja każdej encji odbywa się za pomocą dedykowanej klasy \texttt{DbContextConfiguration } implementującej interfejs \texttt{IEntityTypeConfiguration<T>}. W tej konfiguracji definiowane są szczegóły dotyczące mapowania encji na tabele.
\\\\
Dla każdej encji w aplikacji zostało utworzone dedykowane repozytorium, które jest odpowiedzialne za wykonywanie operacji na danych. Każde repozytorium posiada odpowiadający mu interfejs znajdujący się w warstwie aplikacji. Repozytoria pełnią rolę abstrakcyjnej warstwy dostępu do danych, umożliwiając wykonywanie operacji na danych z bazy.
\\\\
Wszystkie elementy związane z EF i repozytoriami są rejestrowane w kontenerze IoC (Inversion of Control) za pomocą metody rozszerzającej AddPostgres. Metoda ta umożliwia skonfigurowanie połączenia z bazą PostgreSQL oraz rejestrację wszystkich repozytoriów w kontenerze usług, dzięki czemu są one dostępne w całej aplikacji. Takie podejście wspiera modularność oraz ułatwia zarządzanie zależnościami.

% \vspace{0.5cm}
% \begin{figure}[h!]
%     \centering
%     \includegraphics[width=1\textwidth]{images/ex_infra_extensions.png}
%     \caption{Fragment kodu: Rejestracja kontekstu oraz repozytoriów.}
% \end{figure}

\vspace{0.5cm}
\begin{lstlisting}[language=CSharp]
private static IServiceCollection AddPostgres(this IServiceCollection services, IConfiguration configuration) {
    var options = configuration.GetOptions<PostgresOptions>("Postgres");
    services.AddDbContext<ChessAppDbContext>(ctx
        => ctx.UseNpgsql(options.ConnectionString));
    services.AddScoped<IUserRepository, UserRepository>();
    return services;
}
\end{lstlisting}

\newpage

\noindent \textbf{Zadania cykliczne}\\
Zadania cykliczne w projekcie to procesy działające w tle, które są wykonywane w określonych odstępach czasu bez konieczności interakcji użytkownika. W aplikacji takie zadania realizuje się za pomocą klasy, która dziedziczy po \texttt{BackgroundService}. Dzięki temu mechanizmowi zadania te są uruchamiane automatycznie podczas działania aplikacji i wykonują swoją logikę w nieskończonej pętli, z uwzględnieniem przerw między iteracjami.
\\\\
W projekcie zadanie cykliczne odpowiedzialne jest za monitorowanie i automatyczne kończenie gier sieciowych, które spełniają określone warunki. Do jego realizacji wykorzystano wstrzykiwanie zależności, umożliwiając dostęp do dedykowanego serwisu wykonującego kluczowe operacje. Takie podejście pozwala na regularne przetwarzanie danych w tle, co wpływa na płynność działania aplikacji i automatyzację procesów.
\\\\

\noindent \textbf{Obsługa błędów}\\
Obsługa błędów w projekcie została zaprojektowana w sposób centralny, co ułatwia zarządzanie wyjątkami i poprawia doświadczenie użytkownika. Wykorzystuje się w tym celu middleware, który przechwytuje wszystkie wyjątki generowane podczas obsługi żądań i mapuje je na odpowiednie kody statusu HTTP.
\\\\
Obsługa błędów została zaimplementowana za pomocą klasy \texttt{ExceptionMiddleware}, która pełni rolę middleware w aplikacji ASP.NET Core. Middleware przechwytuje wszystkie wyjątki, które mogą wystąpić podczas obsługi żądań HTTP, i mapuje je na odpowiednie kody statusu HTTP:

\begin{itemize}
    \item \textbf{400 (Bad Request):} dla wyjątków BadRequestException, gdy żądanie jest niepoprawne.
    \item \textbf{404 (Not Found):} dla wyjątków NotFoundException, gdy żądany zasób nie istnieje.
    \item \textbf{401 (Unauthorized):} dla wyjątków UnauthorizedException, gdy użytkownik nie jest autoryzowany.
    \item \textbf{500 (Internal Server Error):} dla wszystkich pozostałych nieobsłużonych błędów.
\end{itemize}

\newpage

\subsubsection{Wykorzystane pakiety i biblioteki}

\noindent
W projekcie zastosowano szereg bibliotek, które wspierają rozwój i funkcjonalność aplikacji. Każda z wymienionych bibliotek została dobrana w celu spełnienia konkretnych wymagań funkcjonalnych i architektonicznych projektu, co pozwala na jego rozwój zgodny z najlepszymi praktykami. Poniżej przedstawiono szczegółowy opis wybranych komponentów:

\begin{itemize} 
    \item \textbf{Swashbuckle.AspNetCore} i \textbf{SignalRSwaggerGen}: Biblioteki do generowania dokumentacji Swagger dla API REST i SignalR w jednej konfiguracji.
    \item \textbf{AutoMapper}: Biblioteka umożliwiająca mapowanie obiektów między warstwami aplikacji, eliminując potrzebę ręcznego mapowania.
    \item \textbf{MediatR}: Implementuje wzorzec Mediatora, ułatwiając luźne powiązanie komponentów w aplikacjach CQRS.
    \item \textbf{Npgsql.EntityFrameworkCore.PostgreSQL}: Umożliwia korzystanie z PostgreSQL w aplikacjach .NET za pomocą EF Core.
    \item \textbf{FluentAssertions}: Biblioteka do tworzenia bardziej czytelnych asercji w testach jednostkowych.
    \item \textbf{Microsoft.AspNetCore.SignalR}: Obsługują komunikację w czasie rzeczywistym i kontrolują dostęp do zasobów serwera z innych domen.
    \textbf{Microsoft.AspNetCore.Authentication.JwtBearer}: Wspieraja uwierzytelnianie i autoryzację, w tym logowanie z użyciem JWT.
    \item \textbf{Microsoft.AspNetCore.Mvc.Core} i \textbf{Microsoft.AspNetCore.Mvc.Testing}: Odpowiedzialne za budowanie endpointów API oraz testowanie aplikacji.
    \item \textbf{Microsoft.IdentityModel.Tokens}: Umożliwia tworzenie i weryfikację tokenów, takich jak JWT, w aplikacjach z uwierzytelnianiem opartym na tokenach.
    \item \textbf{Microsoft.Extensions.*}: Zestaw bibliotek wspierających konfigurację aplikacji i wstrzykiwanie zależności.
    \item \textbf{Microsoft.NET.Test.Sdk}, \textbf{xUnit}, \textbf{xUnit.runner.visualstudio} i \textbf{Moq}: Biblioteki do testowania aplikacji, wspierające testy jednostkowe, integracyjne oraz generowanie mocków i uruchamianie testów w Visual Studio.
\end{itemize}

\newpage

\subsection{Warstwa Kliencka (Frontend)}

\subsubsection{Architektura i struktura}

\noindent
Struktura frontendu w tym projekcie jest zorganizowana w sposób umożliwiający łatwe zarządzanie kodem, dzięki zastosowaniu odpowiednich folderów i podfolderów, które odpowiadają za różne aspekty aplikacji. W głównym folderze \texttt{src} znajdują się trzy foldery oraz pliki aplikacji. Każdy z folderów ma swoją specyficzną rolę w organizacji kodu.

\vspace{0.5cm}
\noindent
\begin{minipage}[t]{0.45\textwidth} 
    \vspace{0pt} 
    \justifying 
    \noindent 
    Folder \texttt{index} zawiera router odpowiedzialny za strony ogólnodostępne, takie jak strona główna, rejestracja czy informacje o aplikacji. Folder \texttt{main} jest przeznaczony do zarządzania zasobami dostępnymi tylko dla zalogowanych i zweryfikowanych użytkowników. Dostęp do tych stron jest kontrolowany na podstawie stanu autoryzacji użytkownika, co zapewnia bezpieczeństwo aplikacji. Folder \texttt{shared} natomiast zawiera komponenty i funkcjonalności, które są współdzielone pomiędzy różnymi częściami aplikacji. Każda z sekcji ma wyraźnie określoną rolę i zakres odpowiedzialności, co sprzyja porządkowi w projekcie i ułatwia dalsze rozwijanie aplikacji.
\end{minipage} 
\hfill 
\begin{minipage}[t]{0.45\textwidth} 
    \vspace{0pt} 
    \centering 
    \includegraphics[width=\linewidth]{images/struktura_front.png}
    \captionof{figure}{Struktura projektu warstwy klienckiej.}
\end{minipage}
\vspace{0.5cm}

\noindent
Ponadto na najniższym poziomie struktury projektu dodano lub automatycznie wygenerowano szereg plików odpowiedzialnych za konfigurację zarówno samego projektu, jak i środowiska deweloperskiego.

\newpage

\noindent
Folder \texttt{shared} w projekcie jest zaprojektowany w sposób, który sprzyja ponownemu wykorzystaniu kodu i organizacji wspólnych zasobów używanych w całej aplikacji. Zawiera on różnorodne podfoldery, które grupują funkcje, komponenty i style, w zależności od ich roli w projekcie.

\begin{itemize}
    \item \textbf{components:} przechowuje małe, wielokrotnie używane komponenty, które są wykorzystywane w różnych miejscach aplikacji.
    \item \textbf{styles:} zawiera globalne definicje stylów SCSS. Są tam zdefiniowane zmienne, które ułatwiają zarządzanie kolorami, czcionkami, a także mixiny, które pomagają w definiowaniu jednolitych stylów elementów. Dzięki temu stylowanie jest bardziej spójne i łatwiejsze do modyfikacji w jednym miejscu. Wszystkie współdzielone style są zbierane z różnych plików do jednego - \texttt{shared.scss}, ktory to następnie jest importowany do wszystkich komponentów strony.
    \item \textbf{svgs:} gromadzi wszystkie ikony i mapy ikon, które są wielokrotnie używane w aplikacji. Mapy ikon to funkcje, które na podstawie podanej nazwy ikony zwracają odpowiedni tag svg, co pozwala na łatwe zarządzanie ikonami w projekcie.
    \item \textbf{utils:} zawiera dodatkowe narzędzia, które wspomagają działanie aplikacji. Jest podzielony na kilka podfolderów:
    \begin{itemize}
        \item \textbf{functions:} zawiera globalne i współdzielone funkcje, podzielone na pliki w zależności od ich zastosowania. Można tu znaleźć funkcje pomocnicze, które są wykorzystywane w różnych częściach aplikacji.
        \item \textbf{hooks:} zawiera niestandardowe \texttt{hooki}, które są ponownie wykorzystywane w różnych komponentach.
        \item \textbf{objects:} przechowuje stałe wartości, listy, obiekty i słowniki.
        \item \textbf{services:} zawiera zbiory funkcji lub klasy odpowiedzialne za konkretne zadania w aplikacji.
        \item \textbf{types:} zawiera wszystkie ogólne typy i interfejsy TypeScript, które są wykorzystywane w aplikacji. Obejmuje to zarówno własne definicje typów, jak i przetłumaczone modele danych i DTO z backendu. Dzięki temu struktura danych w obu aplikacji jest spójna, co minimalizuje ryzyko błędów związanych z niezgodnością typów danych.
    \end{itemize}
\end{itemize}

\newpage

\subsubsection{Routing aplikacji}

\noindent
Aplikacja jest podzielona na dwie główne sekcje routingu: ogólnodostępną i zabezpieczoną, których odpowiadają dwa główne routery: \texttt{Index} i \texttt{Main}. Każda z tych sekcji zarządza dostępem do różnych zasobów w zależności od stanu uwierzytelnienia użytkownika.
\\\\
\noindent
\textbf{IndexRouter} odpowiada za strony ogólnodostępne, które mogą być odwiedzane przez każdego użytkownika, bez konieczności logowania. Użytkownicy mogą swobodnie przeglądać te zasoby, bez jakichkolwiek ograniczeń dostępu.

% \vspace{0.5cm}
% \begin{figure}[h!]
%     \centering
%     \includegraphics[width=0.7\textwidth]{images/ex_index_router.png}
%     \caption{Fragment kodu: Schemat routingu ogólnodostępnych zasobów.}
% \end{figure}

\vspace{0.5cm}
\begin{lstlisting}[language=JSX]
<Route path="/" element={<IndexPage />} />
<Route path="/registration" element={<RegisterPage />} />
<Route path="/about" element={<AboutPage />} />
<Route path="/about/:contentName" element={<AboutPage />} />
<Route path="*" element={<NotFoundPage path={"/"} />} />
\end{lstlisting}
\vspace{0.5cm}

\noindent
\textbf{MainRouter} natomiast obsługuje zasoby, które są dostępne tylko dla zarejestrowanych i zweryfikowanych użytkowników. W tej części aplikacji przed uzyskaniem dostępu do stron, przeprowadzana jest weryfikacja, czy użytkownik jest odpowiednio zalogowany i posiada uprawnienia do korzystania z zasobów. Jeśli użytkownik nie spełnia wymogów, zostaje przekierowany do strony rejestracji.

% \vspace{0.5cm}
% \begin{figure}[h!]
%     \centering
%     \includegraphics[width=0.7\textwidth]{images/ex_main_router.png}
%     \caption{Fragment kodu: Schemat routingu zabezpieczonych zasobów.}
% \end{figure}

\vspace{0.5cm}
\begin{lstlisting}[language=JSX]
<Route path="/" element={<MainPage />} />
<Route path="/users" element={<UsersPage />} />
<Route path="/await/:gameIdStr" element={<AwaitingPage />} />
<Route path="/game/:gameIdStr" element={<WebGamePage />} />
<Route path="/engine-game/:gameIdStr" element={<EngineGamePage />} />
<Route path="/account" element={<AccountPage />} />
<Route path="/profile/:friendshipIdStr" element={<ProfilePage />} />
<Route path="/ranking" element={<RankingPage />} />
<Route path="*" element={<NotFoundPage path={"/main"} />} />
\end{lstlisting}

\newpage

\noindent \textbf{Autoryzacja}\\
Autoryzacja w routerze polega na weryfikacji tokena użytkownika oraz stanu jego konta. Przy każdym wejściu na zasoby chronione, aplikacja najpierw sprawdza, czy w \texttt{localStorage} znajduje się token. Jeśli go brak, użytkownik jest przekierowywany do strony rejestracji. Następnie, jeśli token jest obecny, aplikacja sprawdza, czy adres e-mail użytkownika został zweryfikowany. W przypadku braku weryfikacji, użytkownik zostaje przekierowany do strony rejestracji z komunikatem o konieczności weryfikacji konta. Po pomyślnym zweryfikowaniu konta, aplikacja pobiera dane użytkownika, zapisuje je w lokalnym schowku i nawiązuje połączenie z serwisem gier. W przypadku jakichkolwiek problemów z autoryzacją, użytkownik jest również kierowany do strony rejestracji z odpowiednim komunikatem o błędzie. Poniżej przedstawiono fragment kodu z komponentu \texttt{MainRouter}, odpowiadającego za weryfikacje użytkowników.

\vspace{0.5cm}
\begin{lstlisting}[language=JSX]
// sprawdzenie czy token istnieje
const token = localStorage.getItem("token");
if (!token) {
    navigate("/registration");
    return;
} 

// sprawdzenie czy email jest zweryfikowany
const response = await axios.get<IsEmailVerifiedDto>(userController.isVerified(), getAuthorization());
if (!response.data.isEmailVerified){
    navigate("/registration");
    return;
} 

// pobranie danych uzytkownika
const userInfoResponse = await axios.get<GetUserDto>(userController.getUser(), getAuthorization());
localStorage.setItem("userInfo", JSON.stringify(userInfoResponse.data));

// autoryzacja
setAuthorize(true);
\end{lstlisting}

% \vspace{0.5cm}
% \begin{figure}[h!]
%     \centering
%     \includegraphics[width=1\textwidth]{images/ex_router_authorization.png}
%     \caption{Fragment kodu: Proces autoryzacji użytkownika.}
% \end{figure}

\newpage

\subsubsection{Komponenty interfejsu użytkownika}

\noindent \textbf{Strona tytułowa (Index)}\\
Strona tytułowa stanowi pierwsze spotkanie użytkownika z aplikacją. Zawiera ona szereg sekcji, które mają na celu zaprezentowanie aplikacji w sposób przejrzysty i zachęcający do dalszej interakcji. Sekcje na tej stronie obejmują ogólne wprowadzenie do gry w szachy, zasady gry oraz możliwość szybkiego rozpoczęcia gry online lub offline. Celem tej strony jest zainteresowanie użytkownika, zrozumienie, czym jest aplikacja i zachęcenie go do rejestracji lub logowania.
\\

\noindent \textbf{Strona informacyjna (About)}\\
Strona informacyjna zawiera szczegółowe informacje na temat aplikacji, jej twórców, celu, zasad działania, jak również warunki korzystania z platformy i politykę prywatności. Jest to miejsce, gdzie użytkownicy mogą zapoznać się z pełnym opisem aplikacji, jej funkcji, zasadami bezpieczeństwa oraz wymaganiami. Dzięki tej stronie użytkownik zyskuje pełen obraz tego, czego może oczekiwać od aplikacji, a także jest informowany o zasadach korzystania z usługi.
\\

\noindent \textbf{Strona do rejestracji (Register)}\\
Strona rejestracji i logowania jest komponentem, umożliwiającym użytkownikowi utworzenie konta, zalogowanie się lub przejście przez proces weryfikacji. Strona składa się z jednego okna, które zmienia się dynamicznie w zależności od podjętej akcji przez użytkownika. Może to obejmować różne stany, takie jak formularz rejestracji, formularz logowania lub okno informacyjne o konieczności weryfikacji konta po jego utworzeniu. Wszystkie te akcje są obsługiwane w ramach jednego komponentu, który dynamicznie przełącza widoki w zależności od wyboru użytkownika.
\\

\noindent \textbf{Strony ładowania (Loading)}\\
Aplikacja zawiera również strony ładowania, które są wyświetlane w sytuacjach, gdy użytkownik musi poczekać na załadowanie zasobów lub wykonanie operacji, takich jak pobieranie danych z serwera. Strony te pełnią rolę informacyjną i zapewniają użytkownikowi feedback na temat aktualnego stanu procesu, na przykład ładowania gry, oczekiwania na odpowiedź z serwera lub innych operacji wymagających czasu.

\newpage

\noindent \textbf{Strona główna (Main)}\\
Strona główna, dostępna zaraz po zalogowaniu, stanowi centrum nawigacji aplikacji. Z jej poziomu użytkownik może rozpocząć grę, zapoznać się z historią swoich poprzednich gier, a także przejść do innych sekcji, takich jak konto użytkownika, znajomi, ranking czy ustawienia. Strona ta pełni rolę wprowadzenia do pełnej funkcjonalności aplikacji, umożliwiając użytkownikowi szybki dostęp do najistotniejszych opcji. Oprócz rozpoczęcia nowych gier i przeglądania starych, użytkownik może również zapraszać znajomych do gry lub przejrzeć dostępne tryby rozgrywki.
\\

\noindent \textbf{Strona gry online (WebGame)}\\
Jest to komponent odpowiedzialny za rozgrywki online. Mechanizm gry w tym przypadku oparty jest na interakcji dwóch graczy, którzy mogą rywalizować ze sobą w czasie rzeczywistym. Gra jest synchronizowana na bieżąco za pomocą mechanizmów, takich jak SignalR, co pozwala na natychmiastowe przesyłanie danych o wykonanych ruchach i stanie gry między użytkownikami. Strona ta oferuje interfejs umożliwiający pełną interakcję z planszą szachową, a także daje możliwość korzystania z dodatkowych funkcji, takich jak czat czy podgląd statystyk. Wygląd strony jest zoptymalizowany pod kątem dynamicznej gry online, zapewniając użytkownikowi płynne doświadczenie.
\\

\noindent \textbf{Strona gry offline (EngineGame)}\\
Ten komponent odpowiada za tryb gry z komputerem, czyli tryb offline. W tym przypadku użytkownik gra przeciwko sztucznej inteligencji (AI), a rozgrywka jest realizowana w trybie offline, bez potrzeby połączenia z innym graczem. Mechanizmy gry różnią się od tych w trybie online, gdyż cała interakcja odbywa się tylko po stronie użytkownika i aplikacji, bez wymiany danych z zewnętrznymi źródłami. Strona EngineGame jest pod względem wyglądu podobna do strony WebGame, jednak w tym przypadku użytkownik nie ma możliwości zaproszenia znajomych do gry, a interakcja opiera się wyłącznie na grze z komputerem.
\\

\noindent \textbf{Strona konta użytkownika (Account)}\\
Strona konta użytkownika to miejsce, w którym użytkownik może przeglądać i edytować swój profil. Zawiera ona informacje na temat użytkownika, takie jak nazwa, zdjęcie profilowe oraz inne szczegóły, które można zmieniać. Dodatkowo, użytkownik ma dostęp do ustawień konta, takich jak zmiana hasła czy wygląd gry. Strona ta zawiera również sekcję z podsumowaniem statystyk gracza – liczba wygranych gier, liczba rozegranych partii i inne osiągnięcia.

\newpage

\noindent \textbf{Strona zarządzania znajomymi (Users)}\\
Umożliwia ona użytkownikowi zarządzanie znajomymi i zapraszanie nowych osób do gry. Na tej stronie użytkownik może przeglądać swoich znajomych bądź wyszukiwać innych graczy. Jest to także miejsce, gdzie można przeglądać historię zaproszeń i statusy wysłanych zaproszeń. Użytkownik ma możliwość usuwania znajomych lub zatwierdzania nowych zaproszeń.
\\

\noindent \textbf{Strona profilu znajomego (Profile)}\\
Strona ta pozwala na podgląd profili innych użytkowników. Dzięki tej stronie użytkownik może zapoznać się z danymi innych graczy, ich statystykami oraz historią gier w relacji. Umożliwia to łatwiejsze nawiązanie kontaktu i zaproszenie do gry. Strona ta pełni funkcję informacyjną, pozwalając użytkownikowi lepiej poznać innych graczy oraz historie ich znajomości.
\\

\noindent \textbf{Strona rankingu (Ranking)}\\
Strona rankingu pokazuje aktualne rankingi graczy, zarówno na poziomie globalnym, jak i wśród znajomych. Użytkownik może przeglądać globalne rankingi, zobaczyć, jak plasuje się w porównaniu do innych graczy, jak również sprawdzić wyniki swoich znajomych. Ranking jest aktualizowany na bieżąco, odzwierciedlając wyniki wszystkich gier rozegranych w aplikacji. Dzięki temu użytkownicy mogą śledzić swoje postępy i starać się poprawić swoją pozycję w rankingu.
\\

\noindent \textbf{Strona błędu (NotFoundPage)}\\
Strona błędu wyświetla się, gdy użytkownik próbuje uzyskać dostęp do nieistniejącej lub niedostępnej ścieżki w aplikacji. Jest to komponent informujący użytkownika o błędnym adresie URL lub próbie dostępu do zasobu, który został usunięty lub zmieniony. Strona ta zawiera czytelny komunikat o błędzie, a także odnośnik umożliwiający powrót do strony głównej. Dzięki temu użytkownik ma możliwość szybkiego odzyskania kontroli i powrotu do korzystania z funkcjonalności aplikacji.

\newpage

\noindent
Po opisaniu zasad działania routingu w aplikacji oraz przedstawieniu wszystkich głównych komponentów, warto przedstawić diagram ilustrujący strukturę nawigacji i przepływ między poszczególnymi sekcjami. Diagram ten pomoże zrozumieć zależności pomiędzy komponentami oraz sposób, w jaki routing obsługuje żądania użytkowników w zależności od ich stanu uwierzytelnienia i wymaganych uprawnień.

\vspace{1cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{images/diagram_routing.png}
    \caption{Diagram blokowy przedstawiający schemat routingu aplikacji. Opracowany za pomocą aplikacji Viso.}
\end{figure}

\newpage

\subsubsection{Zarządzanie stanem aplikacji}

\noindent
Zarządzanie stanem aplikacji w projekcie opiera się na elastycznym wykorzystaniu kilku mechanizmów w zależności od charakteru stanu i jego zastosowania. Dzięki temu aplikacja jest w stanie skutecznie zarządzać zarówno lokalnym stanem komponentów, jak i bardziej złożonymi danymi związanymi z rozgrywką, zapewniając płynność i responsywność działania aplikacji. Poniżej przedstawiono szczere metod zastosowanych do zarządzania stanem aplikacji:

\begin{itemize}
    \item \textbf{Zarządzanie stanem lokalnym:} Do zarządzania stanem lokalnym, który jest związany z pojedynczymi komponentami, wykorzystywane jest \texttt{useState}. Tego typu stan przechowuje dane dotyczące interakcji użytkownika z interfejsem. Stan ten jest zmieniany w odpowiedzi na działania użytkownika lub pobieranie danych z serwera.

    \item \textbf{Zarządzanie bardziej złożonym stanem:} W przypadku bardziej skomplikowanego stanu, takiego jak stan gry, zastosowano technike \texttt{useReducer}, pozwalającą na lepsze zarządzanie złożonymi i dynamicznymi danymi. Dzięki zastosowaniu reducerów możliwe jest łatwe śledzenie zmian stanu oraz utrzymywanie porządku w logice aplikacji, szczególnie w sytuacjach, gdy wiele akcji może wpływać na jeden obiekt stanu.

    \item \textbf{Globalny stan aplikacji:} Aby zarządzać danymi, które muszą być dostępne w wielu częściach aplikacji, wykorzystywany jest globalny stan oparty na \texttt{useContext} i \texttt{createContext}. Dzięki temu możliwe jest centralne przechowywanie i udostępnianie informacji, które są wykorzystywane w różnych miejscach aplikacji.

    \item \textbf{Przechowywanie danych w localStorage:} Aplikacja wykorzystuje także \texttt{localStorage} do przechowywania niektórych danych, takich jak informacje o użytkowniku czy tokeny logowania. Dzięki temu dane te pozostają dostępne pomiędzy sesjami użytkownika, nawet po odświeżeniu strony lub zamknięciu aplikacji. Ten sposób zapewnia trwałość przechowywanych danych.

    \item \textbf{Komunikacja w czasie rzeczywistym z użyciem SignalR:} W aplikacji szachowej wykorzystano SignalR do synchronizacji stanu gry w czasie rzeczywistym. Po każdym ruchu gracza, aplikacja natychmiastowo informuje drugiego gracza o zmianach, umożliwiając płynne i bieżące aktualizowanie stanu gry bez opóźnień. Obaj gracze widzą zmiany na planszy i mogą od razu reagować na ruchy przeciwnika.

\end{itemize}

\newpage

\subsubsection{Mechanizm gry w szachy}

\noindent
Na następnych stronach zostały przedstawione diagramy prezentujące mechanizmy gier sieciowych oraz z siankiem szachowym. Poniżej przedstawiono legendę, określającą znaczenie kolorów bloków na schematach.
\\\\
\textbf{\colorbox{ForestGreen!90}{\textcolor{ForestGreen}{-----}}} - zapytanie typu POST\\
\textbf{\colorbox{Cerulean!90}{\textcolor{Cerulean}{-----}}} - zapytanie typu GET\\
\textbf{\colorbox{Dandelion!90}{\textcolor{Dandelion}{-----}}} - aktualizacja stanu aplikacji klienckiej\\
\textbf{\colorbox{LimeGreen!90}{\textcolor{LimeGreen}{-----}}} - aktualizacja widoku użytkownika\\
\textbf{\colorbox{BlueViolet!90}{\textcolor{BlueViolet}{-----}}} - event aplikacji klienckiej\\
\textbf{\colorbox{Plum!90}{\textcolor{Plum}{-----}}} - event zwiazany z SignalR\\
\vspace{0.5cm}

\noindent \textbf{Gra w trybie sieciowym}\\
Proces zarządzania przebiegiem gry w szachy w aplikacji opiera się na dynamicznym śledzeniu i aktualizowaniu stanu gry w odpowiedzi na interakcje użytkownika. Cała procedura składa się z kilku etapów, które są ze sobą ściśle powiązane, aby zapewnić płynność rozgrywki i zgodność z zasadami szachów.

\begin{enumerate}
    \item \textbf{Pobranie stanu gry}\\
    Pierwszym krokiem jest pobranie aktualnego stanu gry z bazy danych, co pozwala na załadowanie pozycji wszystkich figur na planszy w chwili, gdy użytkownik wchodzi na stronę gry. Stan gry obejmuje pozycję wszystkich figur, informacje o graczach oraz inne dane związane z przebiegiem partii. Te dane są następnie zapisywane w bieżącym stanie aplikacji, co umożliwia dalsze operacje na szachownicy.

    \item \textbf{Mapowanie pozycji na macierz szachownicy}\\
    Po załadowaniu stanu gry, aplikacja przekształca dane dotyczące pozycji figur w odpowiednią macierz, która reprezentuje szachownicę. Dzięki temu można łatwo manipulować danymi i aktualizować widok planszy. Każda figura jest przypisana do konkretnych współrzędnych na planszy, co umożliwia jej wyświetlenie w odpowiednim miejscu. Mapowanie pozycji do macierzy pozwala również na łatwiejsze śledzenie możliwych ruchów dla każdej figury oraz przeprowadzać pozostałem operacje i obliczenia z wykorzystaniem intuicyjnego systemu koordynat.

\newpage

    \item \textbf{Kontrolowanie pól}\\
    Aplikacja następnie tworzy listy kontrolowanych pól dla obu graczy. Każde pole, na którym może wystąpić bicie, jest uwzględniane w tych listach, podzielnych między dwóch graczy. Najważniejszym elementem tego mechanizmu jest zapewnienie, że król nie może wejść na pole, które jest zagrożone przez przeciwnika. Lista kontrolowanych pól jest dynamicznie aktualizowana po każdym ruchu, aby zapewnić prawidłową grę.

    \item \textbf{Sprawdzanie szacha}\\
    Kolejnym istotnym etapem jest sprawdzenie, czy w danej chwili istnieje szach, czyli w sytuacji w której król jednego z graczy znajduje się pod bezpośrednim atakiem przeciwnika, co oznacza, że gracz musi podjąć działania w celu ochrony swojego króla. Jeśli występuje szach, aplikacja identyfikuje wszystkie pola, które biorą udział w szachu, co pozwala na zmuszenie gracza do podjęcia odpowiednich działań. Oznacza to, że gracz nie może swobodnie poruszać innymi figurami, a ruchy, które nie przerywają zagrożenia, są blokowane.

    \item \textbf{Wyczyszczenie wcześniejszych wyborów}\\
    Po wykonaniu każdego ruchu lub interakcji z użytkownikiem, aplikacja wyczyści wszelkie wcześniejsze wybory dokonywane przez gracza. Na przykład, jeśli użytkownik wybrał figurę, a następnie nie wybrał jej nowej lokalizacji, poprzedni wybór zostaje anulowany. Zapewnia to, że nie pozostają żadne błędne lub nieaktualne dane, które mogłyby wpłynąć na dalszą grę. Zanim gracz będzie mógł dokonać wyboru figury, aplikacja sprawdza, czy istnieje jakikolwiek możliwy ruch, który można wykonać. Jeśli żaden ruch nie jest możliwy, gra zostaje zakończona. W przypadku matu jedna ze stron wygrywa, natomiast w przypadku patu gra kończy się remisem. Aplikacja automatycznie wykrywa te sytuacje i odpowiednio kończy grę.

    \item \textbf{Wybór figury i koordynat}\\
    Gracz może wybrać figurę, którą chce ruszyć. Po dokonaniu wyboru, aplikacja zapisuje wybraną figurę oraz jej koordynaty na planszy. Następnie, użytkownik wybiera pole, na które chce wykonać ruch. W tym momencie aplikacja uruchamia procedurę obliczania wszystkich możliwych ruchów, jakie figura może wykonać na podstawie aktualnych zasad gry. W przypadku nietypowego stanu gry,  pola podpowiedzi ruchów są odpowiednio filtrowane i redukowane.

\newpage

    \item \textbf{Podświetlanie dostępnych pól}\\
    Po obliczeniu dostępnych ruchów, aplikacja aktualizuje widok planszy, podświetlając odpowiednie pola, na które wybrana figura może się poruszyć. Dzięki temu użytkownik ma pełną widoczność swoich opcji i może łatwiej podjąć decyzję. Podświetlone są tylko te pola, które są zgodne z zasadami ruchów danej figury, co eliminuje możliwość wykonania błędnego ruchu.

    \item \textbf{Wykonanie ruchu}\\
    Po dokonaniu wyboru pola przez użytkownika, aplikacja sprawdza, czy ruch jest dozwolony. Jeśli tak, wykonuje ruch, przenosząc figurę na nowe pole. Jeżeli ruch jest nielegalny tj. figura nie może poruszyć się na to pole zgodnie z zasadami gry, aplikacja anuluje wybór i pozwala graczowi ponownie wybrać figurę i cel ruchu.

    \item \textbf{Aktualizacja stanu gry}\\
    Po wykonaniu ruchu aplikacja zapisuje nowy stan gry w bazie danych, co pozwala na kontynuowanie gry od tego punktu w przyszłości. Zmiany w stanie gry obejmują aktualizację pozycji figur, liczbę wykonanych ruchów oraz ewentualne zmiany w statusie gry. Dzięki temu stan gry jest synchronizowany i zabezpieczony na wypadek przerwania gry lub ponownego załadowania strony.

    \item \textbf{Powiadomienie drugiego gracza}\\
    Na końcu, po zapisaniu zmian w bazie, aplikacja powiadamia drugiego gracza o wykonanym ruchu, aby umożliwić mu podjęcie swojej tury. Powiadomienie jest realizowane za pomocą technologii SignalR, która zapewnia natychmiastową synchronizację stanu gry pomiędzy graczami. To kluczowy element umożliwiający grę online w czasie rzeczywistym, gdzie każdy ruch jednego gracza jest natychmiastowo widoczny dla drugiego gracza.

\end{enumerate}

\newpage

\noindent
Poniżej przedstawiony został diagram blokowy ilustrujący proces działania mechanizmu gry w szachy. Diagram prezentuje kolejne etapy, począwszy od inicjalizacji stanu gry, przez interakcje użytkownika, aż po synchronizację stanu gry pomiędzy graczami. Każdy etap jest odzwierciedleniem opisanego wcześniej przebiegu logiki gry, uwzględniając kluczowe decyzje i akcje, takie jak obliczanie możliwych ruchów, weryfikacja poprawności ruchu czy zakończenie gry.

\vspace{1cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{images/diagram_gry.png}
    \caption{Diagram blokowy mechanizmu gry w szachy. Opracowany za pomocą aplikacji Viso.}
\end{figure}

\newpage

\noindent \textbf{Gra z silnikiem szachowym}\\
W przypadku gier z silnikiem szachowym mechanizmy rozgrywki są niemal identyczne jak w grach online. Kluczową różnicą jest jednak brak wykorzystania technologii SignalR. Rozgrywka przebiega sekwencyjnie od początku do końca: po wykonaniu ruchu przez gracza aplikacja wysyła zapytanie do serwera, aby pobrać ruch zaproponowany przez silnik, a następnie wykonuje ruch jako odpowiedź przeciwnika.
\\\\
Środowisko niejako \textit{symuluje} przeciwnika użytkownika, tworząc tymczasowe stany gry uzupełniane danymi wygenerowanymi przez silnik. Po otrzymaniu propozycji ruchu silnika wykonywana jest pełna procedura ruchu, z pominięciem sprawdzania jego legalności, ponieważ ten aspekt jest kontrolowany przez sam silnik szachowy.

% \vspace{0.5cm}
% \begin{figure}[h!]
%     \centering
%     \includegraphics[width=1\textwidth]{images/ex_engine_move_sim.png}
%     \caption{Fragment kodu: Symulacja ruchu zaproponowanego przez silnik.}
% \end{figure}
% \vspace{0.5cm}

\vspace{0.5cm}
\begin{lstlisting}[language=JSX]
// symulacja stanu gry
const tempEngineGameState: EngineGameStates = {...};

// pobranie ruchu zaproponowanego przez silnik
const response = await axios.get<GetEngineGameMoveDto>(engineGameController.getEngineGameMove(gameId), getAuthorization());

// konczenie gry jesli powinna sie zakonczyc
if (response.data.shouldEnd) {...}

// symulacja wyboru silnika
const [toX, toY] = response.data.newCoordinates.split(",");
const [fromX, fromY] = response.data.oldCoordinates.split(",");
const enginePiece = tempEngineGameState.matrix[parseInt(fromY) - 1][parseInt(fromX) - 1] as PieceOption;
const tempEngineSelection: SelectionStates = {...};

// wykonanie ruchu
await makeMove(...);
\end{lstlisting}
\vspace{0.5cm}


\noindent
Jak widać na załączonym przykładzie program tworzy identyczny obiekt jaki jest wykorzystywany do śledzenia wyborów użytkownika, z pominięciem nieistotnych wartości a następnie korzystając z tych samych funkcji jak w przypadku gry online, program wykonuje ruch podany przez AI. 

\newpage

\noindent
Poniżej przedstawiony został uproszony diagram blokowy przedstawiający działanie mechanizmu gry z przeciwnikiem komputerowym. Diagram zawiera tylko kluczowe zmiany, odnoszące się do komunikacji z silnikiem szachowym, natomiast pozostała funkcjonalność pozostaje identyczna, jak w przypadku mechanizmu gier online. pominięte zostały między innymi aspekty końca gry, czy rozdzielnia wyborów użytkownika na opcje przed wybraniem figury i po wyborze, ponieważ są one identyczne w tym trybe gry offline.

\vspace{1cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{images/diagram_enggry.png}
    \caption{Diagram blokowy mechanizmu gry z silnikiem. Opracowany za pomocą aplikacji Viso.}
\end{figure}

\newpage

\subsubsection{Kluczowe aspekty gry}

\noindent \textbf{Podstawowe oznaczenia}\\
Notacja Forsytha-Edwardsa (FEN) – zapis szachowy do określenia pozycji gry szachowej. Celem FEN jest podanie wszystkich niezbędnych informacji do ponownego rozpoczęcia gry od danej pozycji. FEN bazuje na systemie wymyślonym przez szkockiego dziennikarza Davida Forsytha. Jego system stał się popularny w XIX wieku; Steven J. Edwards rozwinął system by mógł działać z komputerami. FEN jest częścią Portable Game Notation dla szachów, dlatego że definiuje pozycje inne od początkowej. \cite{WikiNotacjaForsytha}
\\\\
W formacie FEN figury szachowe są oznaczane literami, przy czym wielkie litery reprezentują figury białe, a małe litery figury czarne. Król oznaczany jest jako \textbf{K/k}, hetman jako \textbf{Q/q}, wieża jako \textbf{R/r}, goniec jako \textbf{B/b}, skoczek jako \textbf{N/n}, a pion jako \textbf{P/p}.
\\\\
Przy wszelkich obliczeniach związanych z ruchami figur oraz analizą innych aspektów gry szachowej wykorzystano system wektorów. Wektory te pozwalają precyzyjnie opisać ruchy każdej figury na szachownicy w formie zestawu współrzędnych. Poniżej przedstawiono dwa zestawy takowych wektorów.
\\\\
Wektory ruchów figur poruszających się liniowo i diagonalnie:

\[ \quad 
\begin{bmatrix}
    [0, 1] & [0, -1] & [1, 0] & [-1, 0] & [1, 1] & [1, -1] & [-1, 1] & [-1, -1]
\end{bmatrix}
\]

\noindent
Specyficzne wektory ruchów skoczka:

\[ \quad 
\begin{bmatrix}
    [1, 2] & [1, -2] & [-1, 2] & [-1, -2] & [2, 1] & [2, -1] & [-2, 1] & [-2, -1]
\end{bmatrix}
\]

\newpage

\noindent \textbf{Oznaczenie ruchu}\\
Ruchy figurami są zapisywane w sposób precyzyjny i zrozumiały, zawierając wszystkie istotne informacje o wykonanej akcji. Składa się z kilku elementów:

\begin{itemize}
    \item \textbf{Symbol figury:} jeśli ruch dotyczy pionka, jest on pomijany.
    \item \textbf{Koordynaty pola początkowego:} współrzędne w formacie [A-H][1-8].
    \item \textbf{Znak bicia:} oznaczany jako znak „x”.
    \item \textbf{Koordynaty pola docelowego:} współrzędne w formacie [A-H][1-8].
    \item \textbf{Promocja pionka:} W przypadku promocji, dodaje się oznaczenie „=(symbol figury)”.
    \item \textbf{Szach lub mat:} oznaczone przez symbole: „+” szach oraz „\#”.
    \item \textbf{Czas wykonania ruchu:} podawany w przypadku gry z czasem.
\end{itemize}

\vspace{0.5cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.5\textwidth]{images/imp_moves.png}
    \caption{Przykładowe ruchy wykonane podczas gry.}
\end{figure}
\vspace{0.5cm}

\noindent \textbf{Pozycja FEN}\\
Pozycja FEN (Forsyth-Edwards Notation) to sposób zapisywania aktualnej sytuacji na szachownicy, który pozwala na jednoznaczne odtworzenie pozycji w dowolnym momencie gry. Zawiera wszystkie istotne informacje o rozmieszczeniu figur, kolorze gracza, który ma wykonać ruch, stanie roszady, liczbie ruchów od ostatniego bicia lub ruchu pionkiem, oraz liczbie pełnych ruchów.
\\\\
W kontekście aplikacji, zapis FEN jest wykorzystywany do przechowywania stanu gry w bazie danych. Dzięki temu możliwe jest zapisanie aktualnej pozycji w dowolnym momencie, a następnie jej odczytanie i przywrócenie, co pozwala na wznowienie gry lub analizę wcześniejszych stanów.

\begin{center}
    \texttt{rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1}
\end{center}

\newpage

\noindent
Przedstawioną przykładową pozycje można podzielić kolejno na części oznaczające:

\begin{itemize}
    \item Rozmieszczenie figur na szachownicy, z użyciem liter oraz liczb wskazujących puste pola.
    \item Kolor gracza, który ma wykonać ruch.
    \item Informacja o dostępności roszady dla obu graczy.
    \item Pozycja pionka, który może wykonać ruch en passant.
    \item Liczba ruchów od ostatniego bicia lub ruchu pionkiem.
    \item Liczba pełnych ruchów.
\end{itemize}

\noindent \textbf{Macierz szachownicy}\\
W pierwszej części zapisu pozycji FEN znajdują się informacje o rozmieszczeniu figur na szachownicy. Program przetwarza ten zapis, mapując go na macierz 8x8, co umożliwia łatwiejsze operowanie na koordynatach. Dzięki tej mapie, każdy element (pole) szachownicy może być odwoływany za pomocą indeksów, co ułatwia implementację ruchów, sprawdzanie stanu gry, a także operacje na poszczególnych figurach. Na przykład, każdemu polu szachownicy przypisane są współrzędne (x, y), gdzie x to numer kolumny (od A do H), a y to numer wiersza (od 1 do 8). Taki sposób reprezentacji umożliwia wygodną manipulację i analizowanie stanu gry.

\vspace{0.5cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.7\textwidth]{images/ex_matrix.png}
    \caption{Przykładowa macierz pozycji gry.}
\end{figure}

\newpage

\noindent \textbf{Ruchy figur}\\
Proces wykonywania ruchów w programie opiera się na mechanizmie identyfikacji możliwych posunięć dla wybranej figury. Gdy użytkownik wybierze figurę, uruchamiana jest metoda \texttt{find} z klasy \texttt{FindMoves}. Metoda ta analizuje aktualną pozycję na szachownicy i zwraca listę pól, na które dana figura może się legalnie przemieścić zgodnie z zasadami gry. Następnie, jeśli użytkownik wskaże jedno z pól podanych w tej liście, ruch zostaje wykonany, a szachownica zostaje zaktualizowana o nową pozycję figury. 

\vspace{0.5cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.5\textwidth]{images/imp_move_tips.png}
    \caption{Wizualizacja podpowiedzi ruchu.}
\end{figure}
\vspace{0.5cm}

\noindent
Po kliknięciu przez użytkownika na pole znajdujące się na liście pól podpowiedzi wywoływana jest funkcja \texttt{makeMove}. Funkcja ta tworzy oznaczenie ruchu w formacie FEN, które dokładnie opisuje wykonany ruch. Następnie aktualizowana jest zarówno bieżąca pozycja FEN, jak i macierz pozycji. Funkcja ta również aktualizuje stany gry, przechowujące dane niezbędne dla ruchów specjalnych. Po przeprowadzeniu tych aktualizacji następuje rozdzielenie logiki w zależności od trybu gry:

\begin{itemize}
    \item \textbf{Gra sieciowa:} Wywoływana jest metoda huba SignalR, w celu powiadomienia drugiego gracza o wykonanym ruchu.
    \item \textbf{Gra z silnikiem:} Następuje wywołanie API kontrolera odpowiedzialnego za interakcję z silnikiem szachowym.
\end{itemize}

\newpage

\noindent \textbf{Szach}\\
Jest to sytuacja, w której król jednego z graczy znajduje się pod atakiem przeciwnika, co oznacza, że przeciwnik mógłby zbić króla w swoim kolejnym ruchu. W odpowiedzi na szach gracz musi podjąć ruch eliminujący zagrożenie dla króla. Nieodpowiedzenie na szach jest niedozwolone, ponieważ król nigdy nie może pozostawać na szachowanym polu. Jeśli gracz nie ma możliwości zneutralizowania szacha, partia kończy się matem. Istnieją trzy możliwe sposoby na uniknięcie szacha:

\begin{itemize}
    \item Przesunięcie króla na pole, które nie jest zagrożone przez przeciwnika.
    \item Zasłonięcie króla inną figurą, jeśli zagrożenie pochodzi z linii działania.
    \item Zbicie atakującej figury, jeśli jest to możliwe.
\end{itemize}

\noindent
W projekcie sytuacja szachu została rozwiązana poprzez tworzenie dwóch par list. Pierwsza z nich obejmuje pola kontrolowane, czyli te, na które figury przeciwnika mogą wykonać bicie. Pola te są wykorzystywane do zapewnienia, że król nie może wejść na pole, na którym byłby zagrożony zbiciem, a także do sprawdzania, czy aktualnie znajduje się w szachu, jeśli stoi na takim polu.
\\\\
Druga para to listy pól biorących udział w szachu. Obejmują one pole zajmowane przez figurę szachującą oraz wszystkie pola, przez które szach jest „przekazywany”. Pola te są wykorzystywane do ograniczenia możliwych ruchów innych figur, tak aby uniemożliwić wykonanie ruchu niezapewniającego zakończenia szachu. Dzięki temu mechanizmowi tylko ruchy ratujące króla są dopuszczalne w trakcie szachu.

\vspace{1cm}
\noindent
\begin{minipage}[t]{0.45\textwidth} 
    \vspace{0pt} 
    \centering 
    \includegraphics[width=\linewidth]{images/imp_front_check_areas.png}   
    \captionof{figure}{Pola szachu.}
\end{minipage} 
\hfill 
\begin{minipage}[t]{0.45\textwidth} 
    \vspace{0pt} 
    \centering 
    \includegraphics[width=\linewidth]{images/imp_front_controlled_areas.png} 
    \captionof{figure}{Kontrolowane pola.}
\end{minipage}

\newpage


\noindent \textbf{Szach podwójny}\\
Jest to sytuacja, w której dwie figury biorą udział w szachu, a kierunki wykonywania szachow zawsze muszą być inne. Szach podwójny występuje wyłącznie w sytuacji szachu z odsłony, gdy dwie różne figury jednocześnie atakują króla przeciwnika. W grze szachowej może wystąpić jedynie szach zwykły lub szach podwójny – nie jest możliwe, aby więcej niż dwie figury jednocześnie szachowały króla. W praktyce istnieją następujące sytuacje, które mogą spowodować szach podwójny:

\begin{itemize}
    \item Goniec odsłania figure atakującą w liniach prostych.
    \item Wieża odsłania figure atakującą po diagonalach.
    \item Skoczek odsłania jakąkolwiek figure poruszającą się liniowo.
\end{itemize}

\noindent
W programie mechanizm obsługi szachu podwójnego został zaimplementowany poprzez sprawdzanie liczby figur znajdujących się na polach biorących udział w szachu. Jeśli zostaną wykryte dwie figury szachujące króla, a wybrana przez gracza figura nie jest królem, pola podpowiedzi ruchów zostają wyzerowane. Wynika to z faktu, że w przypadku szachu podwójnego jedynym dozwolonym ruchem jest przesunięcie króla na bezpieczne pole.

\vspace{0.5cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.5\textwidth]{images/imp_double_check.png}
    \caption{Przykład szachu podwójnego.}
\end{figure}

\newpage

\noindent \textbf{Mat i Pat}\\
W szachach mat oraz pat to dwie podstawowe sytuacje kończące grę. Mat oznacza, że król jednego z graczy jest w szachu i nie ma żadnych dostępnych ruchów, które mogłyby go uratować. Gra kończy się zwycięstwem przeciwnika. Pat, z kolei, ma miejsce wtedy, gdy gracz nie jest w szachu, ale nie ma żadnego legalnego ruchu, który mógłby wykonać. W takiej sytuacji gra kończy się remisem.
\\\\
W implementacji gry, te dwa scenariusze są rozwiązywane poprzez sprawdzanie dostępnych ruchów dla gracza, który jest aktualnie w turze. Gdy gracz próbuje wykonać ruch, najpierw sprawdzane jest, czy istnieje jakikolwiek możliwy ruch. Jeśli po sprawdzeniu okazuje się, że gracz nie ma żadnych możliwych ruchów, następnie sprawdzane jest, czy jego król znajduje się w szachu. Jeśli król jest w szachu, oznacza to, że gra kończy się matem, a zwycięzcą zostaje przeciwnik. W przeciwnym przypadku, jeżeli gracz nie ma ruchu, ale jego król nie jest w szachu, oznacza to, że mamy do czynienia z patem, a gra kończy się remisem.
\\\\
Funkcja \texttt{checkIfAnyMoveExists} odpowiada za cały opisany mechanizm. Używa ona macierzy pozycji, aby sprawdzić każde pole na szachownicy oraz korzysta z mechanizmu klasy \texttt{FindMoves} do znajdywania podpowiedzi, aby okreslic czy figura moze wykonac ruch. W ten sposób nie ma konieczności tworzenia całej implantacji sprawdzania każdej figury, sama funkcja kończy swoje działanie po natrafieniu na pierwszego pionka, który może wykonać ruch.

\vspace{0.5cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.5\textwidth]{images/imp_front_checkmate.png}
    \caption{Przykładu zakończenia gry matem.}
\end{figure}

\newpage

\noindent \textbf{Pin (Związanie)}\\
Związanie jest to sytuacja w której jedna z figur poruszających się liniowo atakuje bierke przeciwnika po lini na której stoi jego król. Powoduje to przywiązanie figury w obecnie znajdującym się miejscu, gdyż poruszenie jest skutkowałoby odsłonięcie własnego króla, co jest ruchem niedozwolonym. W szachach ruchy dzielą się na liniowe i nieliniowe. Liniowe obejmują ruchy prostoliniowe oraz diagonalne. Figury poruszające się liniowo to wieża, goniec i hetman.
\\\\
W implementacji gry mechanizm wykrywania pina opiera się na analizie linii prostych i diagonalnych między królem a wybraną figurą. Sprawdzane jest, czy w tej samej linii znajduje się figura przeciwnika, zdolna do wykonania ruchu liniowego. Jeśli taka sytuacja występuje, to ruchy wybranej figury są ograniczone do kierunku pina.

\vspace{0.5cm}
\noindent
\begin{minipage}[t]{0.45\textwidth} 
    \vspace{0pt} 
    \centering 
    \includegraphics[width=\linewidth]{images/imp_front_linear.png} 
    \captionof{figure}{Ruchów liniowych na przykładzie ruchów hetmana.}
\end{minipage} 
\hfill 
\begin{minipage}[t]{0.45\textwidth} 
    \vspace{0pt} 
    \centering 
    \includegraphics[width=\linewidth]{images/imp_front_pin.png} 
    \captionof{figure}{Przykładowy pin na hetmanie.}
\end{minipage}
\vspace{0.5cm}

\noindent
Ponadto, w kontekście końca gry, piny odgrywają istotną rolę w decydowaniu, czy gra powinna się zakończyć. Mogą one ograniczać dostępne ruchy i zmuszać gracza do wykonania ruchu, który może prowadzić do matu lub patu. Gdy pionki, figury lub król zostają "przypięte", ich możliwości manewru są ograniczone, co znacząco wpływa na dalszy przebieg rozgrywki. Dodatkowo, jeśli przypięta figura nie może się poruszyć, może to prowadzić do sytuacji, w której gracz nie ma wystarczającej ilości ruchów do obrony, co przyczynia się do ostatecznego zwycięstwa.

\newpage

\noindent \textbf{Ruchy specjalne}\\
Ruchy specjalne w szachach, są przetwarzane za pomocą zapisanych specjalnych stanów w bazie danych. Na przykład, system przechowuje informacje o tym, czy roszada może zostać wykonana, bazując na wcześniejszych ruchach króla i wieży oraz innych warunkach, takich jak brak przeszkód na drodze. Ponadto, wykorzystywane są stałe wartości, takie jak pozycja pionka (tzw. ranga), które decydują o tym, kiedy dochodzi do promocji pionka, czy też kiedy pionek ma możliwość poruszenia się o dwa pola do przodu.

\vspace{0.5cm}
\noindent
\begin{minipage}[t]{0.6\textwidth} 
    \vspace{0pt} 
    \justifying 
    \noindent 
    \textbf{Roszada}\\
    Roszada jest specjalnym ruchem, który polega na jednoczesnym przesunięciu króla i wieży. Aby ten ruch był możliwy, muszą być spełnione określone warunki, takie jak brak wcześniejszych ruchów króla i wieży oraz brak przeszkód między nimi. Dodatkowo, król nie może być w szachu ani przechodzić przez pole, które jest zagrożone.
\end{minipage} 
\hfill 
\begin{minipage}[t]{0.3\textwidth} 
    \vspace{0pt} 
    \centering 
    \includegraphics[width=\linewidth]{images/imp_front_castling.png} 
    \captionof{figure}{Roszada.}
\end{minipage}

\vspace{0.5cm}

\noindent
\begin{minipage}[t]{0.3\textwidth} 
    \vspace{0pt} 
    \centering 
    \includegraphics[width=\linewidth]{images/imp_front_enpassant.png} 
    \captionof{figure}{En passant.}
\end{minipage} 
\hfill 
\begin{minipage}[t]{0.6\textwidth} 
    \vspace{0pt} 
    \justifying 
    \noindent 
    \textbf{Bicie w przelocie}\\
    Bicie w przelocie jest specyficznym przypadkiem, który może wystąpić, gdy pionek przeciwnika poruszy się o dwa pola do przodu, a nasz pionek znajduje się na sąsiednim polu. W takim przypadku można zbić pionka przeciwnika, jakby poruszył się tylko o jedno pole. System zapisuje koordynat, na którym może paść to bicie w stanie gry.
\end{minipage}

\vspace{0.5cm}

\noindent
\begin{minipage}[t]{0.6\textwidth} 
    \vspace{0pt} 
    \justifying 
    \noindent 
    \textbf{Promocja pionka}\\
    Promocja pionka ma miejsce, gdy pionek dotrze do ostatniej linii planszy. Wtedy gracz ma możliwość wymiany pionka na inną figurę, najczęściej na hetmana, ale także na wieżę, gońca lub skoczka. Promocja jest obsługiwana przez system na podstawie pozycji pionka na planszy, czyli tzw. rangi, która determinuje moment jej wykonania.
\end{minipage} 
\hfill 
\begin{minipage}[t]{0.3\textwidth} 
    \vspace{0pt} 
    \centering 
    \includegraphics[width=\linewidth]{images/imp_front_promotion.png} 
    \captionof{figure}{Promocja.}
\end{minipage}

\newpage

\noindent \textbf{Pozostałe zasady końca gry}\\
W szachach istnieje kilka innych zasad, które mogą prowadzić do zakończenia gry przed standardowym zwycięstwem lub remisem. Oprócz klasycznego szacha-mata, są to zasady, które umożliwiają ogłoszenie remisu, nawet jeśli nie ma bezpośredniego zagrożenia dla króla. System ten wymaga od aplikacji precyzyjnego śledzenia przebiegu gry oraz różnych warunków, które mogą prowadzić do remisu. Oto szczegóły niektórych z tych zasad:

\begin{itemize}
    \item \textbf{Zasada trzykrotnego powtórzenia pozycji}\\
    Zasada ta pozwala ogłosić remis, jeśli ta sama pozycja na szachownicy wystąpiła trzykrotnie podczas gry, pod warunkiem, że pozycje te miały tę samą możliwość wykonania ruchu. W programie realizuje się to przez zapisanie wszystkich wykonanych ruchów oraz ich stanów w bazie danych. Program porównuje zapisaną historię i sprawdza, czy dana pozycja pojawiła się już co najmniej trzykrotnie. Jeśli tak, gra kończy się remisem.

    \item \textbf{Zasada 50 ruchów}\\
    Zasada 50 ruchów oznacza, że jeśli przez 50 kolejnych ruchów nie została wykonana żadna akcja, taka jak ruch pionka lub bicie figury, to gra kończy się remisem. W aplikacji ten stan jest śledzony za pomocą specjalnej zmiennej, która liczy tzw. \texttt{halfmove} (połowa ruchu). Zwiększa się ona o 1 za każdym razem, gdy nie został wykonany ruch pionka lub nie doszło do bicia. Jeśli liczba ta osiągnie 50, program uznaje, że zasada została spełniona i gra kończy się remisem. Jeśli w tym czasie wykonany zostanie ruch pionka lub dojdzie do bicia, licznik jest zerowany.

    \item \textbf{Niewystarczający ilość materiału}\\
    Jeśli na szachownicy nie ma wystarczającej ilości figur, aby móc wykonać mat, gra kończy się remisem. Na przykład, jeśli jeden z graczy ma tylko króla, a drugi gracz ma jedynie króla i jakąkolwiek inną figurę, nie będzie już możliwe zrealizowanie matu. W takim przypadku aplikacja analizuje całą planszę i sprawdza, czy występuje wystarczający materiał do wykonania matu. Jeżeli materiał jest niewystarczający, program ogłasza remis.

\end{itemize}

\newpage

\subsubsection{Stylizacja komponetów}

\noindent
Każdy komponent w projekcie posiada własny folder, w którym znajduje się dedykowany plik stylów o nazwie \texttt{.module.scss}. Dzięki temu stylizacja jest zorganizowana i łatwa do zarządzania. W przypadkach, gdy kilka komponentów o identycznej strukturze i umiejscowieniu wymaga podobnej stylizacji, ale różni się funkcjonalnością, korzystają one ze wspólnego pliku \texttt{.module.scss}. W takim pliku definiowane są style dla każdego z tych komponentów.
\\\\
Mechanizm stylizacji polega na imporcie klas z pliku \texttt{.module.scss} do pliku komponentu. Klasy te są następnie wykorzystywane jako zmienne, co pozwala na dynamiczne ich przypisywanie w zależności od logiki działania komponentu.
\\\\
Dodatkowo w folderze \texttt{shared} znajduje się plik \texttt{shared.scss}, który pełni funkcję centralnego miejsca dla zmiennych i mixinów współdzielonych przez różne komponenty. Plik ten gromadzi zadeklarowane wartości wspólne dla stylów, takie jak kolory, rozmiary czy powtarzające się schematy. Każdy plik stylów komponentów importuje go za pomocą deklaracji:

\begin{verbatim} @use "../shared/styles/shared.scss" as *; \end{verbatim}

\noindent
Dzięki temu wszystkie zmienne i mixiny są dostępne w stylach poszczególnych komponentów, co pozwala na spójność oraz łatwą aktualizację stylów w całym projekcie.
\\\\
Mixiny są jednym z najważniejszych narzędzi oferowanych przez SCSS, umożliwiającym tworzenie wielokrotnego użytku fragmentów kodu CSS. Dzięki nim można zdefiniować zestawy stylów z opcjonalnymi parametrami, które można stosować w różnych miejscach projektu. To podejście znacznie przyspiesza pracę, ponieważ eliminuje konieczność ręcznego powielania kodu i pozwala na łatwą modyfikację stylów w jednym miejscu. Szczególnie dobrze sprawdzają się przy definiowaniu powtarzalnych wzorców, takich jak style przycisków, cieni, animacji czy układów. Ich wykorzystanie zwiększa spójność projektu i ułatwia utrzymanie kodu, co jest kluczowe w przypadku dużych aplikacji z wieloma komponentami. Dzięki mixinom stylizacja staje się bardziej modułowa, elastyczna i łatwa do skalowania.
\\\\
Na zakończenie warto podkreślić, że niemal każdy plik stylizacji komponentu zawiera znaczniki odpowiadające za obsługę mniejszych urządzeń. Dzięki temu strona została zoptymalizowana pod kątem responsywności, co pozwala na jej wygodne użytkowanie na dowolnym rodzaju urządzenia.

\newpage

\subsubsection{Wykorzystane biblioteki}

\begin{itemize} 
    \item \textbf{react} i \textbf{react-dom}: React to biblioteka do tworzenia dynamicznych komponentów UI, a react-dom pozwala na renderowanie tych komponentów w DOM, integrując aplikację React z przeglądarką. 
    \item \textbf{typescript}: Typowanie statyczne dla JavaScript, które pomaga unikać błędów w kodzie oraz poprawia jego skalowalność.
    \item \textbf{@microsoft/signalr}: Biblioteka umożliwiająca komunikację w czasie rzeczywistym między aplikacjami frontendowymi a serwerem. Jest kluczowa do implementacji funkcji czatu, powiadomień lub innych aplikacji wymagających bieżącej wymiany danych w czasie rzeczywistym.
    \item \textbf{axios}: Służy do tworzenia klient HTTP, w celu wysyłania zapytań do API. 
    \item \textbf{history} i \textbf{react-router-dom}: History umożliwia zarządzanie historią przeglądarki, a react-router-dom korzysta z tej biblioteki do obsługi routingu i nawigacji w aplikacjach. 
    \item \textbf{jsonwebtoken} i \textbf{jwt-decode}: Biblioteki związane z uwierzytelnianiem. \texttt{jsonwebtoken} służy do tworzenia i weryfikacji tokenów JWT, które są używane do autoryzacji użytkowników, a \texttt{jwt-decode} umożliwia dekodowanie tych tokenów, pozwalając na ekstrakcję danych.
    \item \textbf{guid-typescript}: Biblioteka umożliwiająca generowanie unikalnych identyfikatorów oraz prace z nimi.
    \item \textbf{vite} i \textbf{vitest}: Vite to bundler i serwer deweloperski, który wspiera nowoczesne technologie, a vitest to framework testowy zoptymalizowany pod kątem ekosystemu Vite, umożliwiający szybkie uruchamianie testów. 
    \item \textbf{@testing-library/dom} i \textbf{@testing-library/react}: Biblioteki do testowania DOM i komponentów React, umożliwiające tworzenie testów integracyjnych w aplikacjach frontendowych. 
    \item \textbf{eslint} i \textbf{@eslint/js}: Narzędzia do analizy kodu w celu wykrywania błędów i wymuszania standardów kodowania.
    \item \textbf{stylelint}: Narzędzie do analizy jakości CSS i SCSS. 
    \item \textbf{sass} i \textbf{scss}: Obie biblioteki to preprocesory CSS, gdzie SCSS jest bardziej zbliżoną do standardowego CSS wersją SASS. Używa się ich do organizowania i modularnego pisania stylów. 
\end{itemize}

\newpage

\section{Instrukcja obsługi}

\subsection{Strona startowa}

\noindent
Strona tytułowa aplikacji do gry w szachy została zaprojektowana jako intuicyjny i funkcjonalny punkt startowy dla użytkowników. Umieszczono na niej wszystkie kluczowe elementy, które pozwalają na łatwe rozpoczęcie korzystania z platformy. W górnej części strony znajdują się przyciski umożliwiające logowanie oraz rejestrację, co pozwala zarówno nowym użytkownikom, jak i tym posiadającym konto na szybki dostęp do zasobów aplikacji.
\\\\
Całość zaprojektowano w sposób przejrzysty i estetyczny, aby zapewnić pozytywne pierwsze wrażenie oraz łatwość w poruszaniu się po stronie. Strona tytułowa pełni rolę wizytówki aplikacji, jednocześnie oferując dostęp do najważniejszych zasobów i funkcji.

\vspace{0.5cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{images/ins_hero.png}
    \caption{Instrukcja: Widok strony startowej.}
\end{figure}
\vspace{0.5cm}

\newpage

\noindent
\begin{minipage}[t]{0.3\textwidth} 
    \vspace{0pt} 
    \centering 
    \includegraphics[width=\linewidth]{images/ins_home.png} 
\end{minipage} 
\hfill 
\begin{minipage}[t]{0.6\textwidth} 
    \vspace{0pt} 
    \justifying 
    \noindent 
    Pierwsza sekcja strony startowej zawiera krótki wstęp o aplikacji, który przedstawia jej główne założenia i funkcjonalności. Znajdują się tu również przyciski umożliwiające szybkie przejście do logowania lub rejestracji, ułatwiając rozpoczęcie korzystania z platformy.
\end{minipage}

\vspace{1cm}

\noindent
\begin{minipage}[t]{0.6\textwidth} 
    \vspace{0pt} 
    \justifying 
    \noindent 
    Druga sekcja, umożliwia szybki dostęp do funkcji rozgrywki. Znajdują się tutaj przyciski pozwalające na szybkie wyszukiwanie gier online z innymi graczami oraz rozpoczęcie gry offline przeciwko komputerowi.
\end{minipage}
\hfill 
\begin{minipage}[t]{0.3\textwidth} 
    \vspace{0pt} 
    \centering 
    \includegraphics[width=\linewidth]{images/ins_play.png} 
\end{minipage} 

\vspace{1cm}

\noindent
\begin{minipage}[t]{0.3\textwidth} 
    \vspace{0pt} 
    \centering 
    \includegraphics[width=\linewidth]{images/ins_learn.png} 
\end{minipage} 
\hfill 
\begin{minipage}[t]{0.6\textwidth} 
    \vspace{0pt} 
    \justifying 
    \noindent 
    Trzecia sekcja, zawiera opisy kluczowych aspektów aplikacji, takich jak jej funkcje edukacyjne i możliwości rozwoju w grze. Na końcu tej sekcji znajduje się przycisk powrotu na górę, który umożliwia użytkownikowi szybki powrót, aby ponownie przejść do logowania lub rejestracji.
\end{minipage}

\vspace{1cm}

\noindent
\begin{minipage}[t]{0.6\textwidth} 
    \vspace{0pt} 
    \justifying 
    \noindent 
    Czwarta sekcja, FAQ (Najczęściej Zadawane Pytania), zawiera odpowiedzi na pytania dotyczące dwóch głównych obszarów: zakładania i zarządzania kontem użytkownika oraz zasad i funkcji związanych z rozgrywkami.
\end{minipage}
\hfill 
\begin{minipage}[t]{0.3\textwidth} 
    \vspace{0pt} 
    \centering 
    \includegraphics[width=\linewidth]{images/ins_faq.png} 
\end{minipage} 

\vspace{1cm}

\noindent
\begin{minipage}[t]{0.3\textwidth} 
    \vspace{0pt} 
    \centering 
    \includegraphics[width=\linewidth]{images/ins_footer.png} 
\end{minipage} 
\hfill 
\begin{minipage}[t]{0.6\textwidth} 
    \vspace{0pt} 
    \justifying 
    \noindent 
    Ostatnia sekcja, Footer, zawiera informacje kontaktowe oraz odnośniki do mediów społecznościowych. Umożliwia użytkownikom łatwy dostęp do danych kontaktowych oraz śledzenia aplikacji na platformach społecznościowych.
\end{minipage}

\newpage

\subsection{Strona rejestracji}

\noindent
Strona rejestracji w aplikacji łączy w sobie wszystkie kluczowe funkcje niezbędne do zarządzania kontem użytkownika. Pozwala na założenie nowego profilu, zalogowanie się na istniejące konto, odzyskanie dostępu w przypadku utraty hasła oraz potwierdzenie adresu e-mail jako element weryfikacji konta. Wszystkie te opcje zostały zaprojektowane w sposób intuicyjny i łatwy w obsłudze, aby zapewnić jak najlepsze doświadczenie użytkownika.
\\\\
Proces rejestracji umożliwia szybkie i bezproblemowe utworzenie konta. Po podaniu podstawowych danych, takich jak adres e-mail, nawa użytkownika oraz hasło, użytkownik otrzymuje wiadomość e-mail z linkiem aktywacyjnym, który potwierdza poprawność podanych informacji i zabezpiecza konto przed nieautoryzowanym dostępem. Logowanie do istniejącego konta odbywa się poprzez wprowadzenie e-maila lub nazwy użytkownika i hasła.
\\\\
W przypadku zapomnianego hasła, strona oferuje funkcję jego odzyskania. Po podaniu adresu e-mail użytkownik otrzymuje szczegółowe instrukcje dotyczące resetowania hasła, co pozwala w bezpieczny sposób odzyskać dostęp do konta. Proces jest prosty i zabezpieczony dodatkowymi krokami weryfikacyjnymi.

\vspace{0.5cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{images/ins_reg.png}
    \caption{Instrukcja: Widok strony rejestracji użytkowników.}
\end{figure}
\vspace{0.5cm}

\newpage

\subsection{Weryfikacja konta}

\noindent
\begin{minipage}[t]{0.55\textwidth} 
    \vspace{0pt} 
    \justifying 
    \noindent 
    Weryfikacja konta to jeden z kluczowych etapów rejestracji, mający na celu zapewnienie bezpieczeństwa danych użytkowników oraz ochronę przed nieuprawnionym dostępem. Po zakończeniu procesu rejestracji aplikacja automatycznie generuje wiadomość e-mail, która zawiera wszystkie informacje niezbędne do ukończenia weryfikacji. System weryfikacyjny nie tylko wspiera proces zakładania konta, ale również jest wykorzystywany przy odzyskiwaniu hasła, co zapewnia spójność działania i zwiększa bezpieczeństwo użytkowników. 
\end{minipage} 
\hfill 
\begin{minipage}[t]{0.35\textwidth} 
    \vspace{0pt} 
    \centering 
    \includegraphics[width=\linewidth]{images/ins_min_ver.png} 
    \captionof{figure}{Okno weryfikacji adresu email.}
\end{minipage}

\vspace{1cm}

\noindent
\begin{minipage}[t]{0.35\textwidth} 
    \vspace{0pt} 
    \centering 
    \includegraphics[width=\linewidth]{images/ins_min_mail.png} 
    \captionof{figure}{Otrzymany email z kodem weryfikacyjnym.}
\end{minipage} 
\hfill 
\begin{minipage}[t]{0.55\textwidth} 
    \vspace{0pt} 
    \justifying 
    \noindent 
    Wiadomość e-mail, zatytułowana "Hello from BRN Chess", zawiera przyjazne powitanie, a także unikalny kod weryfikacyjny przypisany do konkretnego konta użytkownika. Treść e-maila została zaprojektowana tak, aby była czytelna i estetyczna, co pozwala na szybkie odnalezienie wymaganych informacji. Kod weryfikacyjny, przedstawiony w formie wyróżnionego tekstu, należy skopiować i wkleić w dedykowane pole tekstowe w oknie weryfikacji w aplikacji. Po wprowadzeniu kodu i jego zatwierdzeniu konto zostaje w pełni aktywowane, a użytkownik może rozpocząć korzystanie z platformy. 
\end{minipage}

\vspace{1cm}

\noindent
Cały proces został opracowany z myślą o wygodzie użytkownika. Okno weryfikacyjne w aplikacji jest intuicyjne, zawiera czytelne instrukcje oraz widoczne przyciski umożliwiające wprowadzenie kodu. Dodatkowo w przypadku problemów, takich jak brak dostarczenia wiadomości e-mail, aplikacja oferuje możliwość ponownego wysłania kodu weryfikacyjnego za pomocą jednego kliknięcia.

\newpage

\subsection{Strona główna}

\noindent
Strona główna aplikacji szachowej została zaprojektowana z myślą o intuicyjnej nawigacji i szybkim dostępie do kluczowych funkcji, aby zapewnić użytkownikom wygodę i efektywność. Po prawej stronie ekranu znajduje się pasek nawigacji, który umożliwia łatwe przechodzenie między różnymi stronami aplikacji, zapewniając dostęp do wszystkich istotnych sekcji. Pasek został umieszczony w widocznym miejscu, dzięki czemu poruszanie się po aplikacji jest szybkie i płynne.
\\\\
Obok paska nawigacji umieszczono główne przyciski, które prowadzą do najważniejszych funkcji aplikacji. Każdy z nich odpowiada za inną czynność:

\begin{itemize}
    \item \textbf{Gra online:} umożliwia rozpoczęcie partii z innym graczem przez internet.
    \item \textbf{Gra z komputerem:} pozwala zmierzyć się z silnikiem szachowym.
    \item \textbf{Gra ze znajomymi:} umożliwia zapraszanie znajomych do wspólnej gry.
    \item \textbf{Gry użytkownika:} pokazujące zakończone jak i wciąż trwające partie.
    \item \textbf{Zaproszenia do gier:} wyświetla listę otrzymanych zaproszeń do rozgrywek.
\end{itemize}

\vspace{0.5cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{images/ins_main.png}
    \caption{Instrukcja: Widok strony głównej.}
\end{figure}

\newpage

\subsection{Gra online}

\noindent
Po kliknięciu na przycisk gry online, użytkownik zostaje przeniesiony do okna, które pozwala na wybór odpowiedniego trybu kontroli czasowej dla gry. W zależności od preferencji, dostępne są różne opcje czasowe, zgrupowane w kategorie, takie jak bullet, blitz, rapid, classic oraz daily. W aplikacji istnieją tylko domyślne opcje kontroli czasowej gier - użytkownik nie ma możliwości podawania własnych trybów rozgrywki. 
\\\\
Po dokonaniu wyboru jednego z powyższych trybów, ekran zmienia się na widok wyszukiwania przeciwnika. W tym momencie system zaczyna szukać dostępnego gracza o identycznym wyborze kontroli, aby rozpocząć rozgrywkę. Okno wyszukiwania przeciwnika zawiera również opcje anulowania dołączania do gry, w przypadku rezygnacji lub błędnego wyboru.

\vspace{0.5cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{images/ins_min_pvp.png}
    \caption{Instrukcja: Widok wyboru gry online.}
\end{figure}

\newpage

\subsection{Gra offline}

\noindent
Po kliknięciu na przycisk "Gra z komputerem", użytkownik zostaje poproszony o wybór poziomu trudności silnika. Istnieje 20 poziomów, które symbolicznie podzielono na cztery kategorie: standard, intermediate, advanced oraz master. Należy jednak podkreślić, że podział ten ma charakter jedynie orientacyjny i nie wpływa w żaden sposób na faktyczny sposób działania silnika. Jest to tylko sposób ułatwiający użytkownikowi poruszanie się po dostępnych opcjach, a wybór konkretnego poziomu zależy od indywidualnych preferencji gracza.
\\\\
Po dokonaniu wyboru poziomu silnika gra uruchamia się natychmiastowo, a użytkownik może zacząć rywalizować z komputerowym przeciwnikiem. Warto dodać, że w przypadku gry z komputerem nie ma zastosowanej kontroli czasowej, co oznacza, że gracz może spokojnie analizować ruchy bez presji czasu.

\vspace{0.5cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{images/ins_min_pvc.png}
    \caption{Instrukcja: Widok wyboru gry offline.}
\end{figure}

\newpage

\subsection{Gra ze znajomymi}

\noindent
Po kliknięciu na przycisk „Gra ze znajomymi”, użytkownik zostaje przeniesiony do okna, gdzie po lewej stronie znajduje się opcje zapraszania do gry, a po prawej widoczna jest lista wszystkich znajomych, którzy mają konto w aplikacji. Po kliknięciu na kartę znajomego użytkownik zostaje przekierowany do ekranu wyboru czasu gry, podobnie jak w przypadku gry online z losowym przeciwnikiem, gdzie wybiera się jedną z dostępnych opcji czasowych. Po dokonaniu wyboru czasu, gra natychmiast przechodzi do strony oczekiwania na dołączenie drugiego gracza, użytkownik będzie czekał, aż zaproszona osoba zaakceptuje zaproszenie i dołączy do gry.

\vspace{0.5cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{images/ins_min_pvf.png}
    \caption{Instrukcja: Widok wyboru gry ze znajomym.}
\end{figure}

\newpage

\noindent
Po prawej stronie ekranu znajdują się trzy główne opcje umożliwiające zapraszanie do gry. Pierwsza z nich pozwala na filtrowanie znajomych po nazwie użytkownika. Dzięki temu, w przypadku długiej listy znajomych, łatwiej można znaleźć konkretnego gracza. Druga opcja to bezpośrednie zaproszenie przez e-mail. Po podaniu prawidłowego adresu e-mail użytkownik zostaje przekierowany do wyboru czasu gry, tak jak ma to miejsce w przypadku zapraszania znajomego z listy. Dzięki tej funkcji użytkownicy mogą zapraszać do gry nie tylko swoich znajomych, ale także osoby spoza listy znajomych, wystarczy, że podadzą poprawny adres e-mail.
\\\\
Trzecia opcja, „Gra za pomocą wygenerowanego linka”, pozwala na zaproszenie gracza, który nie jest bezpośrednio na liście znajomych. Po dokonaniu wyboru kontroli czasowej, wyświetla się zmodyfikowane okno oczekiwania, w którym pojawi się unikalny link. Za jego pomocą zapraszający gracz będzie mógł zaprosić innego użytkownika do dołączenia do gry. W celu rozpoczęcia gry, zapraszający użytkownik musi skopiować wygenerowany adres i wysłać go znajomemu za pomocą dowolnego komunikatora. Po kliknięciu w link przez zaproszonego gracza, następuje przekierowanie na specjalną stronę, która automatycznie dołączy graczy do gry.

\vspace{0.5cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{images/ins_min_link.png}
    \caption{Instrukcja: Widok rozpoczynania gry przez link.}
\end{figure}

\newpage

\subsection{Gry użytkownika}

\noindent
Po kliknięciu na przyciski wyświetlające gry, użytkownik zostaje przeniesiony do sekcji, w której pojawiają się karty gier. W zależności od wybranego przycisku, wyświetlane są gry w różnych stanach. W sekcji „Wciąż aktywne gry” znajdują się partie, które są w trakcie rozgrywki. Jest to szczególnie użyteczne przy długich czasach gry, gdyż gracze mogą wrócić do nierozgrywanych jeszcze partii, kontynuując je w dowolnym momencie. Sekcja „Zakończone gry” pozwala na przeglądanie gier, które już się zakończyły. Użytkownicy mogą sprawdzić, jak przebiegały rozgrywki, jakie strategie były stosowane i jakie były wyniki. Sekcja „Gry z komputerem” oferuje podobną funkcjonalność, umożliwiając przegląd zakończonych gier przeciwko komputerowemu przeciwnikowi. Dzięki temu gracze mogą łatwo wrócić do swoich partii, analizować je i śledzić postępy w grze. Aby powrocic do gry, użytkownik musi zwyczajnie kliknąć w wybraną kartę.
\\\\
Dodatkowo, we wszystkich tych sekcjach istnieją filtry, które umożliwiają łatwiejsze sortowanie gier. Gracze mogą filtrować partie po różnych kryteriach, takich jak rodzaj kontroli czasowej, co pozwala szybko znaleźć gry o określonym czasie, czy wynik gry, umożliwiając sortowanie na podstawie zwycięstw, porażek lub remisów. Filtry te ułatwiają przeglądanie dużej liczby gier, pomagając użytkownikom szybko odnaleźć interesujące ich rozgrywki i dostosować widok do swoich potrzeb.

\vspace{0.5cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{images/ins_min_games.png}
    \caption{Instrukcja: Widok gier użytkownika.}
\end{figure}

\newpage

\subsection{Zaproszenia}

\noindent
Ostatnia sekcja na głównej stronie to zaproszenia, gdzie użytkownik ma wgląd we wszystkie aktywne oraz wygasłe zaproszenia do gry. Zaproszenia te mają określony czas ważności – wygasają po 15 minutach, dzięki temu użytkownicy mają tylko ograniczony czas na przyjęcie zaproszenia, co wprowadza element dynamiki i pilności w interakcje z innymi graczami.

\vspace{0.5cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{images/ins_min_inv_card.png}
    \caption{Instrukcja: Widok zaproszeń do gry.}
\end{figure}
\vspace{0.5cm}

\noindent
\begin{minipage}[t]{0.45\textwidth} 
    \vspace{0pt} 
    \centering 
    \includegraphics[width=\linewidth]{images/ins_min_inv_popup.png}
    \captionof{figure}{Instrukcja: Wyskakujące okienko otrzymanego zaproszenia.}
\end{minipage} 
\hfill 
\begin{minipage}[t]{0.45\textwidth} 
    \vspace{0pt} 
    \justifying 
    \noindent 
    Dodatkowo, w przypadku gdy użytkownik jest aktywny na stronie, pojawia się specjalnie dedykowane okno popup. Jeśli użytkownik otrzyma zaproszenie do gry, komunikat wyświetli się automatycznie, informując o tym fakcie.
\end{minipage}

\vspace{1cm}

\noindent
\begin{minipage}[t]{0.45\textwidth} 
    \vspace{0pt} 
    \justifying 
    \noindent 
    Podobnie jak w przypadku sekcji gier użytkownika, w sekcji zaproszeń dostępne są filtry w celu wyświetlania zaproszeń z wybranym statusem.
\end{minipage} 
\hfill 
\begin{minipage}[t]{0.45\textwidth} 
    \vspace{0pt} 
    \centering 
    \includegraphics[width=\linewidth]{images/ins_filters.png}
    \captionof{figure}{Instrukcja: Okno filtrów zaproszeń.}
\end{minipage} 

\newpage

\subsection{Strona gry}

\noindent
Na stronie gry, w centralnej części, znajduje się szachownica, która stanowi główny element interfejsu. To tutaj odbywa się sama rozgrywka, a użytkownicy wykonują swoje ruchy. Po obu stronach szachownicy znajdują się panele, które oferują dodatkowe opcje i funkcjonalności, zapewniając pełniejszą kontrolę nad grą i umożliwiając dostęp do różnych narzędzi pomocniczych.

\vspace{1cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{images/ins_webgame.png}
    \caption{Instrukcja: Widok strony gry online.}
\end{figure}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{images/ins_simpgame.png}
    \caption{Instrukcja: Uproszony widok strony gry.}
\end{figure}

\newpage

\noindent
W centralnej części ekranu znajduje się szachownica, której wygląd może być spersonalizowany przez użytkownika w ustawieniach. Po bokach planszy wyświetlane są koordynaty pól (oznaczone literami i cyframi), które pomagają w orientacji na szachownicy. Gracze mogą wybierać i wykonywać ruchy zarówno poprzez kliknięcia, jak i metodę drag and drop, przeciągając figury na odpowiednie pola. Po wykonaniu ruchu przez przeciwnika, odpowiednie pole zostaje podświetlone, co ułatwia śledzenie zmian na planszy. W przypadku zbicia figury, na polu, na którym nastąpiło zbicie, pojawia się mała przekreślona ikona, sygnalizująca utratę figury. Gdy król znajduje się w szachu, jego figura zostaje podświetlona na czerwono, co wskazuje na zagrożenie i konieczność podjęcia działań w celu ochrony króla.

\vspace{1cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{images/ins_min_board.png}
    \caption{Instrukcja: Szachownica.}
\end{figure}

\newpage

\noindent
\begin{minipage}[t]{0.45\textwidth} 
    \vspace{0pt} 
    \justifying 
    \noindent 
    Na prawym pasku widnieje informacja o graczach. Pokazuje ich aktualną punktację ELO oraz przewagę materialną w grze, przeliczoną na figury. Dodatkow zaraz poniżej znajduję się czas jaki pozostał każdemu z graczy, istniejący tylko w grach online.
\end{minipage} 
\hfill 
\begin{minipage}[t]{0.45\textwidth} 
    \vspace{0pt} 
    \centering 
    \includegraphics[width=\linewidth]{images/ins_min_players.png} 
    \captionof{figure}{Gracze i kontrola czasowa.}
\end{minipage}

\vspace{1cm}

\noindent
\begin{minipage}[t]{0.45\textwidth} 
    \vspace{0pt} 
    \centering 
    \includegraphics[width=\linewidth]{images/ins_min_moves.png} 
    \captionof{figure}{Menu poprzednich ruchów.}
\end{minipage} 
\hfill 
\begin{minipage}[t]{0.45\textwidth} 
    \vspace{0pt} 
    \justifying 
    \noindent 
    Kolejna funkcjonalność to menu ruchów, które zostały wykonane. Każdy ruch jest pokazany z ikoną figury, która została użyta, notacją FEN opisującą ruch oraz przybliżonym czasem wykonania ruchu. Na dole menu znajdują się przyciski umożliwiające przewijanie i cofanie, pozwalające na szybki podgląd poprzednich pozycji. Dodatkowo, najeżdżając na konkretny ruch, wyświetla się wizualizacja pozycji po wykonaniu tego ruchu.
\end{minipage}

\vspace{1cm}

\noindent
\begin{minipage}[t]{0.45\textwidth} 
    \vspace{0pt} 
    \justifying 
    \noindent 
    Ostatnia funkcjonalność na prawym pasku to menu wiadomości. Wyświetlane są tam wiadomości wysłane przez użytkowników, jak również automatyczne powiadomienia, takie jak informacje o rozpoczęciu/zakończeniu gry czy oferta remisu. Na dole menu znajduje się pole do wysyłania własnych wiadomości, co umożliwia graczom komunikację w czasie gry. W przypadku gry z silnikiem wysłanie wiadomosci jest zablokowane, a wyświetlane są tylko wiadomości systemowe.
\end{minipage} 
\hfill 
\begin{minipage}[t]{0.45\textwidth} 
    \vspace{0pt} 
    \centering 
    \includegraphics[width=\linewidth]{images/ins_min_mess.png} 
    \captionof{figure}{Menu wiadomości.}
\end{minipage}

\newpage

\noindent
\begin{minipage}[t]{0.25\textwidth} 
    \vspace{0pt} 
    \centering 
    \includegraphics[width=\linewidth]{images/ins_min_wopt.png} 
    \captionof{figure}{Menu akcji - gra online.}
\end{minipage} 
\hfill 
\begin{minipage}[t]{0.65\textwidth} 
    \vspace{0pt} 
    \justifying 
    \noindent 
    Na lewym panelu w przypadku gry online dostępne są opcje zarządzania rozgrywką. Pierwsza z nich to opcja opuszczenia gry, która działa różnie w zależności od długości partii. Dla gier krótkich oznacza to remis, jeśli gra dopiero się rozpoczęła, lub poddanie się, jeśli gra trwa już dłużej. W przypadku gier długich, opuszczenie gry oznacza po prostu wyjście z partii. Kolejna opcja to poddanie się, które kończy grę i uznaje przeciwnika za zwycięzcę. Można również zaproponować remis, co skutkuje wysłaniem oferty do drugiego gracza, który może ją zaakceptować lub odrzucić. Dodatkowo, istnieje opcja blokowania użytkownika, co uniemożliwia wysyłanie wiadomości oraz dodanie takiej osoby do znajomych. Istnieje również możliwość zgłoszenia podejrzenia oszukiwania, co daje użytkownikom narzędzie do zgłaszania nieuczciwych praktyk. Na koniec, dostępne jest ustawienie wyglądu strony gry, w tym zmiana wyglądu szachownicy oraz figur, co pozwala na dostosowanie interfejsu do własnych preferencji.
\end{minipage}

\vspace{1cm}

\noindent
\begin{minipage}[t]{0.65\textwidth} 
    \vspace{0pt} 
    \justifying 
    \noindent 
    W przypadku gry z silnikiem, lewy panel zawiera nieco inne opcje dostosowane do tego trybu gry. Pierwsza opcja to wyjście z gry, która kończy rozgrywkę. Można również zrestartować grę, co rozpoczyna ją od nowa. Dodatkowo dostępna jest opcja poddania się, kończąca partię na korzyść silnika. Istnieje także możliwość cofnięcia ruchu, ale jest to dostępne tylko wtedy, gdy opcja oszukiwania jest włączona w ustawieniach. Kolejną opcją jest zmiana poziomu silnika, która pozwala na dostosowanie trudności rozgrywki, jednak ta funkcja jest także dostępna tylko przy włączonej opcji oszukiwania. Na koniec, jak w przypadku gry online, dostępna jest opcja zmiany ustawień wyglądu strony gry, w tym szachownicy oraz figur, co pozwala na personalizację wizualną rozgrywki.
\end{minipage} 
\hfill 
\begin{minipage}[t]{0.25\textwidth} 
    \vspace{0pt} 
    \centering 
    \includegraphics[width=\linewidth]{images/ins_min_eopt.png} 
    \captionof{figure}{Menu akcji - gra offline.}
\end{minipage}

\newpage

\noindent
Dodatkowo na planszy szachowej pojawiają się wyskakujące okna, które aktywują się po wybraniu odpowiednich opcji przez użytkownika.

\vspace{0.5cm}

\noindent
\begin{minipage}[t]{0.55\textwidth} 
    \vspace{0pt} 
    \justifying 
    \noindent 
    Okno promocji pionka pojawia się, gdy pionek dotrze do ostatniej linii. Użytkownik wybiera jedną z czterech opcji: damę, wieżę, skoczka lub gońca, a pionek zostaje zamieniony na wybraną figurę.
\end{minipage} 
\hfill 
\begin{minipage}[t]{0.35\textwidth} 
    \vspace{0pt} 
    \centering 
    \includegraphics[width=\linewidth]{images/ins_min_prom.png} 
    \captionof{figure}{Okno promocji pinków.}
\end{minipage}

\vspace{1cm}

\noindent
\begin{minipage}[t]{0.35\textwidth} 
    \vspace{0pt} 
    \centering 
    \includegraphics[width=\linewidth]{images/ins_min_prev.png} 
    \captionof{figure}{Okno poprzedniego ruchu.}
\end{minipage} 
\hfill 
\begin{minipage}[t]{0.55\textwidth} 
    \vspace{0pt}
    \justifying 
    \noindent 
    Pokazywanie poprzednich ruchów odbywa się po najechaniu myszką na menu z poprzednimi ruchami lub poprzez kontroli przewijania na dole menu. Po wybraniu ruchu, na szachownicy pojawia się pomniejsza, przyciemniona plansza, która pokazuje wcześniejszą pozycję. Ta zmiana jest tylko wizualna, służy ona jedynie do pokazania poprzedniego stanu gry, co oznacza, że nie istnieje możliwość interakcji z tym oknem.
\end{minipage}

\vspace{1cm}

\noindent
\begin{minipage}[t]{0.55\textwidth} 
    \vspace{0pt} 
    \justifying 
    \noindent 
    Innym wyskakującym oknem jest okno, które pojawia się po zakończeniu gry, niezależnie od wyniku — wygranej, przegranej lub remisie. Na tym oknie wyświetlany jest rezultat gry, czyli informacja, kto wygrał, jaki był powód zakończenia gry oraz punkty zdobyte lub stracone przez graczy. Na dole okna znajdują się przyciski umożliwiające przejście do wyjścia z gry, rozpoczęcia nowej partii lub rozegrania rewanżu, przy czym będą one odbywać z dotychczasową kontrolą czasową. W przypadku gier z silnikiem dostępne są jedynie opcje restartu gry lub wyjścia z gry.
\end{minipage} 
\hfill 
\begin{minipage}[t]{0.35\textwidth} 
    \vspace{0pt} 
    \centering 
    \includegraphics[width=\linewidth]{images/ins_min_win.png} 
    \captionof{figure}{Okno końca gry.}
\end{minipage}

\newpage

\subsection{Strona konta użytkownika}

\noindent
Strona profilu użytkownika zapewnia pełną kontrolę nad ustawieniami konta oraz personalizacją preferencji. Użytkownik ma możliwość edytowania swojego profilu, w tym zmiany danych osobowych, zdjęcia profilowego oraz innych informacji. Na stronie dostępne są szczegółowe statystyki gier, w tym wykresy punktacji dla różnych kategorii czasowych, które pozwalają na analizowanie postępów i wyników w różnych wariantach gier. Użytkownik może również przeglądać listę swoich znajomych, zapraszać ich do gry oraz oglądać ich profile.
\\\\
Dodatkowo, użytkownik ma możliwość edytowania ustawień konta, w tym zmiany hasła oraz zarządzania ustawieniami prywatności, takimi jak widoczność profilu. Można również dostosować wygląd strony gry, zmieniając szachownicę, pionki oraz inne elementy wizualne. Istnieje opcja włączenia funkcji oszukiwania podczas gry z silnikiem, co pozwala na cofanie ruchów lub zmianę poziomu trudności. Strona profilu jest centralnym miejscem, w którym użytkownik może zarządzać wszystkimi aspektami swojego konta i dostosować aplikację do swoich potrzeb.

\vspace{0.5cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{images/ins_account.png}
    \caption{Instrukcja: Widok strony profilu użytkownika.}
\end{figure}

\newpage

\subsection{Strona zarządzania znajomymi}

\noindent
Strona użytkowników służy do zarządzania znajomymi i relacjami z innymi graczami w aplikacji. Jest podzielona na cztery główne sekcje, które pomagają w organizowaniu kontaktów.

\begin{itemize}
    \item \textbf{Wszyscy użytkownicy} – zawiera listę wszystkich graczy dostępnych w aplikacji. Z tej sekcji użytkownicy mogą zapraszać innych do znajomych oraz podglądać ich skrócone wersje profili.

    \item \textbf{Twoi znajomi} – znajdują się tutaj osoby, które zostały już dodane do listy znajomych. Można stąd zapraszać znajomych do gry lub przejść do profilu danego użytkownika. Istnieje także opcja usunięcia użytkownika z grona przyjaciół.

    \item \textbf{Oczekujące zaproszenia} – sekcja zawiera zaproszenia, które zostały wysłane, ale nie zostały zaakceptowane przez drugą stronę. Użytkownicy mogą tu zobaczyć zarówno wysłane zaproszenia, jak i oczekujące na odpowiedź.

    \item \textbf{Odrzucone zaproszenia} – lista osób, które odrzuciły zaproszenia lub które zabkowały użytkownika oraz zablokowani użytkownicy. W przypadku blokad zostaje wstrzymana możliwość interakcji użytkowników na platformie.

\end{itemize}

\vspace{0.5cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{images/ins_users.png}
    \caption{Instrukcja: Widok strony zarządzania znajomymi.}
\end{figure}

\newpage

\subsection{Strona rankingu}

\noindent
Strona rankingu pozwala użytkownikom na sprawdzenie ich pozycji w hierarchii graczy aplikacji. Gracze mogą wybierać między dwoma głównymi opcjami: globalnym rankingiem, który obejmuje wszystkich zarejestrowanych użytkowników aplikacji, oraz rankingiem wśród znajomych, który ogranicza wyświetlane wyniki do osób z listy znajomych.
\\\\
Dodatkowo rankingi są podzielone na pięć kategorii, zależnie od typu kontroli czasowej: bullet, blitz, rapid, classic oraz daily. Dzięki temu gracze mają możliwość sprawdzenia swoich wyników i miejsca w rankingu w kontekście preferowanego rodzaju gry, zarówno na poziomie globalnym, jak i w gronie znajomych.

\vspace{0.5cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{images/ins_rank.png}
    \caption{Instrukcja: Widok strony zarządzania znajomymi.}
\end{figure}
\vspace{0.5cm}

\noindent
Strona rankingu jest kluczowym elementem aplikacji, wspierającym rywalizację i pozwalającym graczom śledzić ich postępy oraz porównywać swoje osiągnięcia z innymi użytkownikami, jak również śledzenie topowych graczy platformy.

\newpage

\section{Testy}

\subsection{Frontend}

\subsubsection{Testy automatyczne}

\noindent
Testy automatyczne frontendu są istotnym elementem w procesie tworzenia nowoczesnych aplikacji internetowych. Ich głównym celem jest zapewnienie wysokiej jakości aplikacji poprzez wczesne wykrywanie błędów, zwiększenie stabilności kodu oraz ułatwienie jego utrzymania i rozwijania. Testowanie automatyczne pozwala również na wprowadzanie zmian w projekcie z mniejszym ryzykiem nieoczekiwanych problemów. Odpowiednio zaplanowane i przeprowadzone testy wspierają procesy ciągłej integracji (Continuous Integration) oraz ciągłego dostarczania oprogramowania (Continuous Delivery), co jest kluczowe w nowoczesnych metodykach zwinnych.
\\\\
Biblioteka @testing-library/react jest jednym z najczęściej wykorzystywanych narzędzi w testowaniu aplikacji zbudowanych w React. Jej projekt skupia się na zapewnieniu testów maksymalnie zbliżonych do rzeczywistego użytkowania aplikacji, co oznacza, że głównym przedmiotem testowania są widoczne rezultaty działania aplikacji oraz jej interakcje. W przeciwieństwie do tradycyjnych podejść, które mogą koncentrować się na szczegółach implementacyjnych, takich jak wewnętrzna struktura DOM czy konkretne klasy CSS, @testing-library/react promuje testowanie z perspektywy użytkownika końcowego.
\\\\
Dodatkowo, @testing-library/react pozwala na tworzenie testów odpornych na zmiany w strukturze implementacyjnej komponentów. Dzięki temu testy są bardziej trwałe i mniej podatne na awarie spowodowane drobnymi zmianami w kodzie, co w efekcie przyspiesza proces ich utrzymania. Takie podejście wspiera budowanie aplikacji skoncentrowanej na użytkowniku, co ma kluczowe znaczenie w przypadku nowoczesnych, dynamicznych aplikacji webowych. Testy napisane w tym stylu dokładniej odzwierciedlają rzeczywiste scenariusze użytkowania, co przekłada się na lepszą ochronę aplikacji przed błędami oraz nieoczekiwanymi zachowaniami w produkcji.

\newpage

\noindent
W projekcie każda strona aplikacji ma dedykowany folder (Page) i plik testowy, który zawiera przypadki testowe dla całego widoku oraz jego komponentów. Organizacja taka ułatwia utrzymanie testów i zwiększa ich czytelność. Testy są tworzone w symulowanym środowisku, wykorzystując mocki API za pomocą narzędzia axios-mock-adapter. Dzięki temu aplikacja jest testowana w izolacji od rzeczywistego serwera, co pozwala sprawdzić jej zachowanie w różnych scenariuszach.

\begin{enumerate}
    \item \textbf{Przygotowanie środowiska testowego:}\\
    Na początku definiowane są mocki, które symulują odpowiedzi serwera. W tym celu użyta została biblioteka axios-mock-adapter. Dzięki niej możliwe jest kontrolowanie żądań wysyłanych przez axios w testach. Dla różnych endpointów API można zdefiniować każdy rodzaj żądania, jak i ich odpowiedzi.

    \item \textbf{Tworzenie obiektów symulujących odpowiedzi serwera:}\\
    Przed rozpoczęciem testu przygotowane zostały obiekty, które będą reprezentować rzeczywiste odpowiedzi serwera, dzięki czemu testy lepiej odzwierciedlają rzeczywiste scenariusze.

    \item \textbf{Konfiguracja środowiska testowego:}\\
    Wykorzystując funkcję \texttt{render} z biblioteki @testing-library/react, następuje render testowanego komponentu w izolowanym środowisku testowym. Często używane są do tego narzędzia takie jak \texttt{MemoryRouter}, które symulują kontekst nawigacji w aplikacjach React opartych na routerze. Dodatkowo definiowane zostają początkowe ścieżki aplikacji oraz komponenty, które mają być testowane.

    \item \textbf{Testowanie elementów początkowych aplikacji:}\\
    Po wyrenderowaniu komponentu można sprawdzić, czy elementy interfejsu użytkownika są widoczne na ekranie. Podczas tego etapu następuje weryfikacja, że aplikacja początkowo renderuje się poprawnie.

    \item \textbf{Symulowanie interakcji użytkownika:}\\
    Kolejnym krokiem jest symulacja interakcji na wygenerowanym komponencie. Ponownie wykorzystana biblioteka udostępnia gotowe rozwiązania w tym celu.

    \item \textbf{Sprawdzanie wyników testu:}\\
    Po wykonaniu akcji użytkownika, przy pomocy funkcji takich jak \texttt{waitFor} sprawdzone zostaje, czy oczekiwane zmiany w interfejsie użytkownika faktycznie zaszły, takiej jak przekierowania na odpowiednie strony, czy render poszczególnych pomniejszych komponentów.

\end{enumerate}

\newpage

\noindent
Przykład testu integracyjnego dla aplikacji przedstawia ogólny schemat, w jaki testy są tworzone w projekcie. Każdy test weryfikuje współdziałanie komponentów, interakcje użytkownika oraz reakcje aplikacji na symulowane odpowiedzi API. Dzięki zastosowaniu narzędzi takich jak axios-mock-adapter możliwe jest dokładne odwzorowanie rzeczywistego środowiska działania aplikacji. Poniżej znajduje się fragment kodu ilustrujący test logowania, który obejmuje symulację żądań serwera, obsługę formularza logowania oraz przejście do głównej strony aplikacji.

% \vspace{0.5cm}
% \begin{figure}[h!]
%     \centering
%     \includegraphics[width=1\textwidth]{images/ex_front_tests.png}
%     \caption{Fragment kodu: Przykład testu komponentu aplikacji klienckiej.}
% \end{figure}
% \vspace{0.5cm}

\vspace{0.5cm}
\begin{lstlisting}[language=JSX]
it("should render without crashing and displays initial content", async () => {
    // mocki zapytan api
    mock.onGet(userController.getRegisterConf(getPasswordRegisterConfModel)).reply(200, responseConfiguration);
    mock.onGet(userController.getRegisterConf(getUserRegisterConfModel)).reply(200, responseConfiguration);

    // wygenerowanie strony
    render(
      <MemoryRouter>
        <RegisterPage />
      </MemoryRouter>
    );

    // sprawdzenie poprawnosci generowania
    expect(await waitFor(() => screen.getByTestId("sign-in-form-modal"))).toBeInTheDocument();
    expect(await waitFor(() => screen.getByText("Login Now"))).toBeInTheDocument();
});
\end{lstlisting}
\vspace{0.5cm}

\noindent
Schemat testów frontendowych nie jest sztywno określony, a jedynie ogólnie przedstawia logikę, która kieruje tworzeniem przypadków testowych. Jest on znacznie bardziej elastyczny w porównaniu do testów aplikacji serwerowej, gdzie testy mają określony i powtarzalny szablon. Taka różnica wynika z natury części frontendowej projektu, gdzie testy muszą uwzględniać różnorodne interakcje użytkownika, które mogą przybierać wiele różnych form i scenariuszy.

\newpage

\subsubsection{Wykonywanie testów automatycznych}

\noindent
W projekcie testy aplikacji frontendowej są uruchamiane za pomocą narzędzia Vitest, które oferuje szybkie i wydajne środowisko testowe. Testy mogą być uruchamiane w trybie interfejsu użytkownika, co pozwala na wygodne monitorowanie wyników testów i łatwe prześledzenie ich postępu. Aby uruchomić testy, używana jest komenda "npm run test:ui", która uruchamia interaktywny interfejs do wyświetlania wyników testów w czasie rzeczywistym. Dzięki temu programista ma pełną kontrolę nad przebiegiem testów oraz łatwy dostęp do szczegółowych informacji na temat ich wyników.

\vspace{0.5cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{images/tests_front.png}
    \caption{Widok interfejsu użytkownika do uruchamiania testów w Vitest.}
\end{figure}
\vspace{0.5cm}

\noindent
Po uruchomieniu testów w trybie UI, można na bieżąco śledzić postęp testów oraz analizować wyniki. Testy, które zakończą się sukcesem, są wyświetlane w odpowiedniej kolorystyce, a te, które zawiodą, są wyraźnie zaznaczone, co ułatwia lokalizowanie problemów. Interfejs użytkownika Vitest umożliwia również szybkie przejście do szczegółowych informacji o błędach, co przyspiesza debugowanie.

\newpage

\subsubsection{Testy maunalne}

\noindent
W projekcie frontendowym testy manualne odgrywają kluczową rolę w zapewnieniu wysokiej jakości aplikacji, szczególnie ze względu na fakt, że to interfejs użytkownika jest bezpośrednio odpowiedzialny za jego doświadczenie (UX). Choć testy automatyczne są niezbędne do weryfikacji funkcji aplikacji i jej komponentów, testy manualne stanowią fundament procesu testowania, ponieważ umożliwiają szczegółowe i subiektywne ocenienie aplikacji z perspektywy rzeczywistego użytkownika.
\\\\
Testowanie manualne jest szczególnie istotne w przypadku aplikacji frontendowych, ponieważ użytkownicy wchodzą w interakcje z interfejsem graficznym, który może wykazywać różne zachowania w zależności od urządzenia, przeglądarki, rozdzielczości ekranu czy środowiska. Manualne testy pozwalają na wychwycenie problemów, które mogą być trudne do zauważenia w testach automatycznych, takich jak błędy w układzie, nieczytelne elementy, nieintuicyjna nawigacja, a także problemy z responsywnością czy kompatybilnością między różnymi platformami.
\\\\
Ważnym aspektem testów manualnych jest możliwość pełnego odwzorowania rzeczywistych scenariuszy użytkowania. Istnieje możliwość przeprowadzania testów na rzeczywistych danych, co pozwala na lepsze zrozumienie, jak aplikacja będzie funkcjonować w praktyce. Testowanie interakcji z danymi pochodzącymi z serwera jest niezbędne, aby sprawdzić, czy wszystkie elementy aplikacji, reagują poprawnie na dane wejściowe użytkownika oraz na odpowiedzi serwera.
\\\\
Dzięki testom manualnym możliwe jest również przeprowadzenie testów związanych z interakcjami pomiędzy różnymi komponentami aplikacji, co daje pełny obraz działania aplikacji w kontekście całościowej interakcji. Na przykład, można sprawdzić, czy różne sekcje aplikacji przełączają się poprawnie, czy animacje są płynne, czy aplikacja reaguje odpowiednio na działania użytkownika, takie jak kliknięcia, wprowadzanie danych czy nawigacja między stronami.
\\\\
W testach manualnych ważna jest także możliwość dokładnego ocenienia użyteczności aplikacji, co jest istotne z perspektywy użytkowników końcowych. Podczas testów można zwrócić uwagę na to, jak intuicyjny jest interfejs, jak łatwo jest przejść przez różne procesy oraz czy użytkownicy mogą w sposób płynny korzystać z aplikacji. Dzięki manualnemu testowaniu możliwe wprowadzenie poprawek, które poprawiają komfort korzystania z aplikacji.

\newpage

\subsection{Backend}

\subsubsection{Testy jednostkowe}

\noindent
Test jednostkowy to rodzaj testu, który sprawdza pojedynczą jednostkę kodu, najczęściej funkcję lub metodę, w ściśle kontrolowanych warunkach. Testy jednostkowe mają na celu weryfikację, czy testowana logika działa zgodnie z oczekiwaniami w różnych scenariuszach, bez potrzeby angażowania zewnętrznych zależności, jak bazy danych, usługi sieciowe czy systemy plików. Dzięki temu, testy jednostkowe mogą być uruchamiane bardzo szybko i zapewniają wysoką precyzję testowania, gdyż wykonują kod w ramach jednego procesu w pamięci. Co istotne, podczas testowania programiści nie muszą ingerować w proces, ponieważ testy te są zaprojektowane tak, by działały samodzielnie w pełni automatycznie, weryfikując prawidłowość działania kodu w różnych, wcześniej zdefiniowanych warunkach. \cite{DevStyleTesty}
\\\\
W kontekście niniejszego projektu, testy jednostkowe zostały zastosowane w celu automatycznej kontroli poprawności działania klas odpowiedzialnych za obsługę zapytań. Każdy przypadek obsługi zapytania, który mógł wystąpić w aplikacji, został przetestowany w ramach osobnego testu jednostkowego. Testy te weryfikują nie tylko prawidłowe działanie procedury, ale również różne scenariusze błędów. Zostały utworzone testy dla każdego możliwego błędu, jaki może pojawić się przy obsłudze zapytania. Dzięki temu, aplikacja jest testowana w pełni automatycznie w różnych kontekstach i zapewnia, że każda część logiki działa zgodnie z założeniami.
\\\\
Zakres testów jednostkowych w projekcie obejmuje jedną obsługę żądania i jego wewnętrzną logikę. Testy jednostkowe skupiają się na indywidualnych metodach i funkcjach w obrębie jednego handlera. Każdy test jest zaprojektowany w taki sposób, aby sprawdzać pojedynczy przypadek użycia, co pozwala na szybkie zidentyfikowanie ewentualnych błędów w jednej, konkretnej logice.
\\\\
Logika tworzenia testów jednostkowych w tym projekcie polega na tym, że dla każdego potencjalnego błędu, który może wystąpić w ramach danego handlera, tworzony jest osobny przypadek testowy. Na przykład, jeśli handler może rzucić różne wyjątki w zależności od sytuacji, dla każdego z tych wyjątków tworzony jest dedykowany test, który sprawdza, czy błąd jest odpowiednio obsługiwany. Dzięki temu testy są wysoce precyzyjne, a ich struktura pozwala na dokładne śledzenie działania aplikacji w różnych, potencjalnie problematycznych scenariuszach. 

\newpage

\noindent
Ogólny proces tworzenia testów jednostkowych wygląda następująco:

\begin{enumerate}
    \item \textbf{Przygotowanie obiektów:}\\
    W każdym teście tworzone są obiekty typu \texttt{Mock} dla zależności, takich jak repozytoria czy serwisy, które pozwalają na kontrolowanie ich zachowania w trakcie testów. Dzięki nim można zasymulować różne scenariusze, bez rzeczywistego ich wywoływania.

    \item \textbf{Utworzenie testowych obiektów:}\\
    W każdym z testów na początku utworzone zostały przykładowe dane, które symulowane metody mogą zwrócić, w celu odwzorowania rzeczywistych scenariuszy. Obiekty te są tworzone w sposób kontrolowany, aby odpowiadały wymaganym warunkom testowym. Mogą zostać utworzone zarówno poprawne obiekty, jak i niepoprawne obiekty, co umożliwia dokładne sprawdzenie, jak system reaguje na różne przypadki.

    \item \textbf{Symulowanie zachowania zależności:}\\
    Za pomocą metody \texttt{Setup} ustawia się, jak dane zależności mają się zachować w czasie wykonywania testu. Na przykład, w przypadku repozytorium użytkowników, można ustawić, by konkretna metoda zwracała wcześniej zadeklarowanego obiekt encji, co umożliwia sprawdzenie, jak system reaguje, gdy obiekty o określonych własnościach już istnieją.

    \item \textbf{Przygotowanie żądania (request):}\\
    Następnie wywoływana jest metoda testowanego handlera, która wykonuje logikę biznesową na podstawie testowych danych wejściowych.

    \item \textbf{Weryfikacja wyników:} \\
    Po wykonaniu metody, weryfikowane są różne aspekty:

    \begin{itemize}
        \item \textbf{Oczekiwane wyjątki:} Sprawdzanie, czy odpowiedni wyjątek, został rzucony w przypadku błędnych danych wejściowych.
        \item \textbf{Zwracane dane:} W przypadku jeśli określonych handler ma za zadanie zwrócić jakieś dane, sprawdzana jest również ich poprawność z oczekiwanymi wartościami.
        \item \textbf{Interakcje z zależnościami:} Sprawdzanie, czy odpowiednie metody w mockowanych zależnościach zostały wywołane odpowiednią liczbę razy.
        \item \textbf{Brak interakcji w przypadku błędów} Jeżeli test sprawdza sytuację błędnego żądania, wówczas testuje się, czy nie zostały wywołane inne metody, które normalnie byłyby uruchomione w przypadku sukcesu.
    \end{itemize}

\end{enumerate}

\newpage

\noindent
Przykład testu jednostkowego dla warstwy \texttt{.Core} przedstawia ogólny schemat, w jaki testy są tworzone w projekcie. Każdy test ma na celu weryfikację poprawności działania metody w różnych scenariuszach. Poniżej znajduje się fragment kodu, który ilustruje przykład takiego testu.

\vspace{0.5cm}
\begin{lstlisting}[language=CSharp]
[Fact]
public async Task Handle_Returns_User_On_Success() {
    // przykladowe dane i zapytanie
    var exampleUser = new Entities.User(){...};
    var request = new GetOtherUserRequest() { UserId = exampleUser.Id,};

    // ustawienie mockow
    _mockUserRepository.Setup(x => x.GetById(request.UserId)).ReturnsAsync(exampleUser);

    // stymulacja
    var handler = new GetOtherUserRequestHandler(
        _mockUserRepository.Object);
    var result = await handler.Handle(request, CancellationToken.None);

    // sprawdzenie wynikow
    result.Username.Should().Be(exampleUser.Username);
    _mockUserRepository.Verify(x => x.GetById(request.UserId), Times.Once);
}
\end{lstlisting}
\vspace{0.5cm}

% \vspace{0.5cm}
% \begin{figure}[h!]
%     \centering
%     \includegraphics[width=1\textwidth]{images/ex_core_test.png}
%     \caption{Fragment kodu: Przykład testu jednostkowego warstwy .Core.Tests.}
% \end{figure}
% \vspace{0.5cm}

\noindent
W projekcie utworzono 238 przypadków testowych, które obejmują wszystkie istotne scenariusze dla każdego handlera. Testy te zostały zaprojektowane w taki sposób, aby sprawdzać nie tylko poprawną realizację procesów, ale także różne sytuacje błędne. Dzięki temu projekt jest bardziej odporny na błędy, a jego stabilność oraz niezawodność zostały zwiększone poprzez sprawdzenie różnych ścieżek, które mogą wystąpić w rzeczywistych warunkach użytkowania aplikacji.
\newpage

\subsubsection{Testy integracyjne}

\noindent
Testy integracyjne to kluczowy etap w procesie tworzenia oprogramowania, który polega na weryfikacji współdziałania różnych komponentów systemu. Ich celem jest sprawdzenie, jak różne części aplikacji, które zostały wcześniej testowane jednostkowo, integrują się ze sobą i jak współpracują w rzeczywistych warunkach. W przeciwieństwie do testów jednostkowych, które skupiają się na testowaniu pojedynczych funkcji lub metod, testy integracyjne obejmują cały proces komunikacji między modułami systemu, w tym bazę danych, usługi zewnętrzne, interfejsy API czy inne komponenty systemowe. \cite{BoringOwlTesty}
\\\\
Podczas testów integracyjnych, główną uwagą jest sprawdzenie, czy dane przechodzą przez cały cykl operacyjny, od momentu ich wprowadzenia, aż do finalnego przetworzenia lub zapisu. Oznacza to, że testy te pomagają wykrywać błędy, które mogą wystąpić w trakcie interakcji między różnymi modułami, takie jak niezgodności w formacie danych, błędy w komunikacji między komponentami lub problemy z dostępem do zewnętrznych usług.
\\\\
W celu przeprowadzenia testów integracyjnych, konieczne jest pełne zrozumienie struktury systemu oraz umiejętność identyfikacji kluczowych punktów interakcji pomiędzy jego elementami. Testowanie takich interakcji wymaga wiedzy o tym, jak system funkcjonuje w całości oraz o tym, jak poszczególne komponenty wzajemnie się wspierają. Ze względu na złożoność takich testów, przeprowadzenie ich może być czasochłonne i wymagające odpowiednich zasobów. Mimo to, testy integracyjne dostarczają bardzo cennych informacji, które pomagają upewnić się, że cały system działa zgodnie z oczekiwaniami i spełnia wymagania użytkownika.
\\\\
W projekcie testy integracyjne są zaprojektowane w taki sposób, aby weryfikowały pełny przepływ danych pomiędzy warstwą aplikacji i bazą danych, a także interakcje z zewnętrznymi zasobami. Są one bardziej złożone i czasochłonne niż testy jednostkowe, ponieważ obejmują całą aplikację, a nie pojedyncze komponenty, ale zapewniają pełniejszy obraz poprawności działania systemu w rzeczywistych warunkach. 

\newpage

\noindent
Główne kroki tworzenia takich testów są następujące:

\begin{enumerate}
    \item \textbf{Konfiguracja środowiska testowego:}\\
    Testy integracyjne wymagają pełnego uruchomienia aplikacji w kontrolowanych warunkach. W tym przypadku używa się specjalnie dedykowanej klasy \texttt{TestWebApplicationFactory}, która odpowiada za wykonanie środowiska testowego, w tym uruchomienie aplikacji oraz jej zależności. Dodatkowo, do testów wykorzystywane są komponenty takie jak \texttt{HttpClient}, który pozwala na symulowanie wysyłania zapytań HTTP, oraz kontekst bazy danych, który umożliwia interakcję z bazą.

    \item \textbf{Utworzenie testowych obiektów:}\\
    W testach integracyjnych tworzone są testowe obiekty, które symulują rzeczywiste dane, które będą przesyłane w zapytaniach. Obiekt modeli są tworzone z danymi, które będą wysyłane jako konkretne żądanie. Obiekty te są konwertowane do formatu JSON, a następnie na \texttt{StringContent}, który jest przesyłany w ciele żądania HTTP.

    \item \textbf{Wysyłanie zapytania HTTP:}\\
    Kluczową częścią testu integracyjnego jest wysłanie zapytania HTTP do odpowiedniego punktu końcowego aplikacji. Dzięki wykorzystaniu \texttt{HttpClient}, test symuluje działanie rzeczywistego użytkownika, który wysyła zapytanie do aplikacji.

    \item \textbf{Sprawdzanie odpowiedzi (asercje):}\\
    Po wysłaniu zapytania, w testach integracyjnych sprawdzana jest odpowiedź z serwera. W przypadku pozytywnego przebiegu rejestracji, status odpowiedzi powinien mieć kod statusu 200. Dodatkowo, testy służące do tworzenia wpisów w tablicach sprawdzają czy obiekty rzeczywiście zostały zapisane.

    \item \textbf{Testowanie niepoprawnych scenariuszy:}\\
    Testy integracyjne obejmują również przypadki nieprawidłowych zapytań. Jeśli użytkownik próbuje wykonać niedowolną operację, aplikacja powinna zwrócić odpowiedź z kodem konkretnego błędu. W takim przypadku test również weryfikuje, czy odpowiedź HTTP ma oczekiwany status oraz czy system prawidłowo reaguje na błędne dane.

\end{enumerate}

\newpage

\noindent 
Przykład testu integracyjnego dla warstwy \texttt{.Api.Tests} przedstawia sposób, w jaki testy są tworzone w projekcie, aby zweryfikować poprawność działania całej aplikacji, w tym interakcji z bazą danych, API oraz innymi zewnętrznymi komponentami. Każdy test integracyjny ma na celu weryfikację, czy różne elementy systemu współdziałają ze sobą zgodnie z oczekiwaniami w kontekście rzeczywistego działania aplikacji. Poniżej znajduje się fragment kodu, który ilustruje przykład takiego testu.

\vspace{0.5cm}
\begin{lstlisting}[language=CSharp]
[Fact]
public async Task Register_Should_Create_User_On_Success() {
    await _dbContext.Init();
    // przykladowe parametry zapytania
    var model = new RegisterUserModel() {...}; 
    var json = JsonConvert.SerializeObject(model);
    var httpContent = new StringContent(json, Encoding.UTF8, "application/json");

    // symulacja
    var response = await _client.PostAsync("api/user/sign-up", httpContent);
    var assertDbContext = _factory.GetDbContextForAsserts();

    // sprawdzenie wynikow
    response.StatusCode.Should().Be(HttpStatusCode.OK);
    var user = await assertDbContext.Users.FirstAsync();
    user.Username.Should().Be("Test");
    user.Email.Should().Be("test@test.com");
}
\end{lstlisting}
\vspace{0.5cm}

% \vspace{0.5cm}
% \begin{figure}[h!]
%     \centering
%     \includegraphics[width=1\textwidth]{images/ex_api_test.png}
%     \caption{Fragment kodu: Przykład testu integracyjnego warstwy .Api.Tests.}
% \end{figure}
% \vspace{0.5cm}

\noindent
W projekcie utworzono 134 przypadków testowych, które obejmują pełny przepływ danych i interakcje między komponentami aplikacji, takimi jak kontrolery API, baza danych i usługi. Testy te zostały zaprojektowane w taki sposób, aby sprawdzać nie tylko poprawność realizacji procesów, ale także różne sytuacje błędne, które mogą wystąpić podczas interakcji między komponentami systemu. Każdy test sprawdza, czy aplikacja reaguje odpowiednio na poprawne i błędne dane wejściowe, weryfikując odpowiedzi HTTP, zapis do bazy danych i inne krytyczne operacje. Dzięki temu projekt jest bardziej odporny na błędy, a jego stabilność oraz niezawodność zostały zwiększone poprzez symulowanie rzeczywistych warunków użytkowania aplikacji.

\newpage

\subsubsection{Wykonywanie testów}

\noindent
Wykonywanie testów w projekcie odbywa się za pomocą środowiska \textbf{Visual Studio}, które oferuje wbudowane narzędzia do uruchamiania i zarządzania testami. Dzieki czemu można w prosty sposób uruchomić i sprawdzić działanie wszystkich utworzonych testów.
\\\\
W Visual Studio dostępne jest także okno \textbf{Test Explorer}, które umożliwia zarządzanie testami. Po otwarciu tego okna, wyświetlają się wszystkie dostępne testy oraz ich statusy. Dzięki tej funkcjonalności można także uruchamiać pojedyncze testy lub zestawy testów.

\vspace{0.5cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{images/vs_tests.png}
    \caption{Widok okna realizacji testów w programie Visual Studio.}
\end{figure}
\vspace{0.5cm}

\noindent
Po wykonaniu testów, w oknie Test Explorer zostaną pokazane wyniki. Testy, które zakończą się sukcesem, będą oznaczone na zielono, a te, które zakończą się niepowodzeniem, na czerwono. Klikając na test, który nie przeszedł, można uzyskać szczegóły błędu, co pozwala szybko zlokalizować problem w kodzie. Visual Studio generuje również raporty, które zawierają informacje o czasie wykonania testów, liczbie zaliczonych i niezaliczonych testów oraz ewentualnych błędach. Dzięki tym funkcjom, Visual Studio jest wygodnym narzędziem do przeprowadzania testów, monitorowania wyników i analizy przebiegu testowania.

\newpage

\section{Podsumowanie}

\noindent
Projekt miał na celu opracowanie nowoczesnej platformy szachowej umożliwiającej grę w trybie online, offline, oraz zintegrowanie dodatkowych funkcjonalności wspierających rywalizację i zarządzanie relacjami między użytkownikami. Realizacja projektu pozwoliła osiągnąć większość zakładanych celów, co stanowi solidną podstawę dla dalszego rozwoju i optymalizacji platformy.
\\\\
Do głównych osiągnięć projektu należy wdrożenie systemu gry online między użytkownikami, który działa stabilnie i spełnia założenia funkcjonalne. Dzięki wykorzystaniu biblioteki SignalR, system rozgrywek online okazał się nie tylko wydajny, ale również elastyczny, zapewniając płynną komunikację w czasie rzeczywistym. Gra offline z komputerem została zrealizowana przy użyciu silnika szachowego Stockfish, który zapewnił najwyższy poziom rozgrywek, jednocześnie będąc narzędziem łatwym do integracji z projektem. Mechanizm ten pozwolił na utworzenie zaawansowanego przeciwnika komputerowego, który dostosowuje swoje ruchy do poziomu umiejętności gracza, co wzbogaciło wrażenia użytkownika.
\\\\
Platforma oferuje także możliwość gry ze znajomymi dzięki wbudowanemu systemowi relacji między użytkownikami. Intuicyjny interfejs użytkownika umożliwia płynne poruszanie się po aplikacji i korzystanie z jej funkcji, takich jak szczegółowe zarządzanie kontem użytkownika, bezpieczeństwo danych czy system rankingu i punktacji, które zwiększają atrakcyjność rywalizacji na platformie ChessBRN. Wprowadzenie kontroli czasowej w grach online stanowi dodatkowy element strategii, co czyni rozgrywkę bardziej emocjonującą i dynamiczną.
\\\\
Pomimo wielu osiągnięć, projekt nie został ukończony w pełnym zakresie ze względu na ograniczenia czasowe. Nie udało się wdrożyć systemu turniejowego, który miał na celu organizowanie bardziej złożonych rozgrywek między użytkownikami. Dodatkowo, rola administratora, która miała obejmować nadzór nad zasadami fair play oraz możliwość banowania oszustów, pozostała niewykorzystana. Pomimo tych braków, obecna wersja aplikacji stanowi solidne i funkcjonalne rozwiązanie, które spełnia potrzeby większości użytkowników.
\\\\
Projekt został zaprojektowany i zrealizowany w większości zgodnie z zasadami SOLID, co pozwoliło zaimplementować przejrzysty, modularny i łatwy w utrzymaniu kod. Strukturę projektu wzbogacają liczne komentarze, które szczegółowo opisują implementację poszczególnych funkcji, co ułatwia zarówno zrozumienie kodu, jak i jego przyszły rozwój. Dzięki temu projekt jest nie tylko funkcjonalny, ale również dobrze udokumentowany.
\\\\
Końcowy etap projektu obejmował testowanie aplikacji, które zostało przeprowadzone zarówno automatycznie, jak i manualnie. Automatyczne testy jednostkowe i integracyjne pozwoliły na weryfikację poprawności działania kluczowych funkcji zarówno po stronie frontendowej, jak i serwerowej. Manualne testy skupiły się na interfejsie użytkownika oraz interakcjach między poszczególnymi komponentami, co było szczególnie istotne w kontekście zapewnienia jak najlepszego doświadczenia użytkownika. Połączenie tych metod pozwoliło na minimalizację błędów oraz zapewnienie stabilności aplikacji, która, choć jeszcze nie w pełni zoptymalizowana, w pełni spełnia kluczowe założenia funkcjonalne projektu.
\\\\
Podsumowując, projekt zrealizował swoje główne cele, dostarczając użytkownikom intuicyjną i atrakcyjną platformę szachową, która łączy nowoczesne technologie z klasyczną grą w szachy. Platforma ChessBRN, choć wciąż posiada potencjał do dalszego rozwoju, jest już teraz funkcjonalnym narzędziem, które w pełni odzwierciedla zaangażowanie zespołu projektowego w opracowaniu wysokiej jakości aplikacji webowej.

\newpage
\begin{thebibliography}{99}

    % szachy
    \bibitem{ChessWiki} 
    Wikipedia, "Chess". Adres url: \url{https://en.wikipedia.org/wiki/Chess}.

    \bibitem{WikiNotacjaForsytha} 
    Wikipedia, "Notacja Forsytha-Edwardsa". Adres url: \url{https://pl.wikipedia.org/wiki/Notacja-Forsytha-Edwardsa}.

    % frontend
    
    \bibitem{JustJoinJS} 
    Just Join IT, "Wszystko co musicie wiedzieć o JavaScript – co to, dla kogo i ile zarobimy". Adres url: \url{https://justjoin.it/blog/wszystko-co-musicie-wiedziec-o-javascript-co-to-dla-kogo-i-ile-zarobimy}.
    
    \bibitem{DropticaTypeScript} 
    Droptica, "Co jest TypeScript i dlaczego sprawdzi się w twoich projektach?". Adres url: \url{https://www.droptica.pl/blog/co-jest-typescript-i-dlaczego-sprawdzi-sie-w-twoich-projektach/}.

    \bibitem{ReactUI} 
    React Team, "Describing the UI". Adres url: \url{https://react.dev/learn/describing-the-ui}.

    \bibitem{ViteGuide} 
    Vite Team, "Vite Guide". Adres url: \url{https://vitejs.dev/guide/}.

    \bibitem{BoringOwlViteJS} 
    Boring Owl, "Przegląd Vite.js – nowa generacja narzędzi do budowania aplikacji front-end". Adres url: \url{https://boringowl.io/blog/przeglad-vitejs-nowa-generacja-narzedzi-do-budowania-aplikacji-front-end}.

    \bibitem{BoringOwlSass} 
    Boring Owl, "Poznaj Sass – zyskaj kontrolę nad stylem swojej strony". Adres url: \url{https://boringowl.io/blog/poznaj-sass-zyskaj-kontrole-nad-stylem-swojej-strony}.

    \bibitem{FrontendArchitecture}
    Microsoft. (2023). \textit{Organizing Your Application in ASP.NET Core}. Adres url:  \url{https://docs.microsoft.com/en-us/aspnet/core/fundamentals/architectural-guidelines?view=aspnetcore-5.0}
    
    % backend

    \bibitem{CSharp}
    Microsoft. \textit{Przewodnik języka C\#}. Adres url:  \url{https://learn.microsoft.com/pl-pl/dotnet/csharp/}

    \bibitem{DotNetStart} 
    Microsoft, \textit{Wprowadzenie do .NET Framework}. Adres url: \url{https://learn.microsoft.com/pl-pl/dotnet/framework/get-started/}.

    \bibitem{EFCoreRelationships} 
    Microsoft. \textit{Relacje, właściwości nawigacji i klucze obce}. Adres url:  \url{https://learn.microsoft.com/pl-pl/ef/ef6/fundamentals/relationships}

    \bibitem{OVHRestAPI} 
    OVHcloud, \textit{Co to jest Rest API}. Adres url: \url{https://www.ovhcloud.com/pl/learn/what-is-rest-api/}.
    

    
    \bibitem{OnionArchitecture} 
    Clarity Ventures. (n.d.). \textit{Onion-based Software Architecture}. Adres url:  \url{https://www.clarity-ventures.com/articles/onion-based-software-architecture}
    
    \bibitem{OnionAdvantages} 
    Medium. (2019, October 21). \textit{Onion Architecture}. Adres url:  \url{https://medium.com/expedia-group-tech/onion-architecture-deed8a554423}
    
    \bibitem{ScalabilityOnion} 
    Anar Solutions. (n.d.). \textit{Onion Architecture: Advantages, Components, and Implementation}. Adres url:  \url{https://anarsolutions.com/onion-architecture}
    
    \bibitem{RestApiOverview}
    OVHcloud. (n.d.). \textit{What is a REST API?}. Adres url:  \url{https://www.ovhcloud.com/pl/learn/what-is-rest-api/}
    
    \bibitem{RestApiMethods}
    Contrive. (n.d.). \textit{HTTP Methods - GET, POST, PUT, DELETE}. Adres url:  \url{https://www.contrive.mobi/aviorapi/HTTPMETHODS.html}

    \bibitem{SwaggerDocumentation}
    Lenkowski, P. (n.d.). \textit{Swagger – czyli jak pisać dokumentację API?}. Adres url:  \url{https://lenkowski.net/swagger-czyli-jak-pisac-dokumentacje-api/}

    \bibitem{SignalR}
    Microsoft. (n.d.). \textit{Use hubs in ASP.NET Core SignalR}. Adres url:  \url{https://learn.microsoft.com/en-us/aspnet/core/signalr/hubs?view=aspnetcore-9.0}
    
    \bibitem{SignalRIntro}
    Medium. (2021, June 15). \textit{Understanding SignalR: Concepts, Features, and Usages}. Adres url:  \url{https://medium.com/%40IntelliSoft/understanding-signalr-concepts-features-and-usages-ed6bf9c17fc7}
    
    \bibitem{SignalRHub}
    Stack Overflow. (2012, March 19). \textit{What do Hub represents in SignalR?}. Adres url:  \url{https://stackoverflow.com/questions/8929519/what-do-hub-represents-in-signalr}

    \bibitem{MediatR}
    Jasper. (2023). \textit{MediatR - Simple, unambiguous mediator for .NET}. Adres url:  \url{https://github.com/justeat/JustSaying}
    
    \bibitem{MediatorPattern}
    Wikipedia. (2023, December 19). \textit{Mediator pattern}. Adres url:  \url{https://en.wikipedia.org/wiki/Mediator_pattern}
    
    \bibitem{HandlerPattern}
    Microsoft. (2023, December 1). \textit{Request and Response Handlers with MediatR}. Adres url:  \url{https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-5.0}

    \bibitem{DTO}
    Martin Fowler. (2003). \textit{Patterns of Enterprise Application Architecture}. Addison-Wesley Professional. ISBN 0321127420.
    
    \bibitem{Pagination}
    Microsoft. (2023). \textit{How to implement pagination in ASP.NET Core}. Adres url:  \url{https://docs.microsoft.com/en-us/aspnet/core/web-api/pagination?view=aspnetcore-5.0}
    
    \bibitem{DataTransferObjects}
    Wikipedia. (2023, December 8). \textit{Data transfer object}. Adres url:  \url{https://en.wikipedia.org/wiki/Data_transfer_object}

    \bibitem{SMTP}
    Microsoft. (2023). \textit{Sending Email with SMTP in ASP.NET Core}. Adres url:  \url{https://docs.microsoft.com/en-us/aspnet/core/architecture/advanced-topics/smtp-email?view=aspnetcore-5.0}
    
    \bibitem{JWT}
    JWT.io. (2023). \textit{Introduction to JSON Web Tokens}. Adres url:  \url{https://jwt.io/introduction/}
    
    \bibitem{EntityFramework}
    Microsoft. \textit{Entity Framework Core Documentation}. Adres url:  \url{https://learn.microsoft.com/en-us/ef/core/}
    
    \bibitem{PostgresEF}
    Npgsql. (2023). \textit{Entity Framework Core and PostgreSQL}. Adres url:  \url{https://www.npgsql.org/efcore/}
    
    \bibitem{IoC}
    Microsoft. (2023). \textit{Dependency Injection in ASP.NET Core}. Adres url:  \url{https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-5.0}

    \bibitem{BackgroundService}
    Microsoft. (2023). \textit{Background Services in ASP.NET Core}. Adres url:  \url{https://docs.microsoft.com/en-us/aspnet/core/fundamentals/hosted-services?view=aspnetcore-5.0}
    
    \bibitem{DependencyInjection}
    Microsoft. (2023). \textit{Dependency Injection in ASP.NET Core}. Adres url:  \url{https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-5.0}
    
    \bibitem{Middleware}
    Microsoft. (2023). \textit{Exception Handling in ASP.NET Core}. Adres url:  \url{https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/exception-handling?view=aspnetcore-5.0}
    
    \bibitem{BoringOwlTesty} 
    Boring Owl, "Testy integracyjne – plusy i minusy ich stosowania". Adres url: \url{https://boringowl.io/blog/testy-integracyjne-plusy-i-minusy-ich-stosowania}.
    
    \bibitem{DevStyleTesty} 
    DevStyle, "Mega piguła wiedzy o testach jednostkowych". Adres url: \url{https://devstyle.pl/2020/06/25/mega-pigula-wiedzy-o-testach-jednostkowych/}.

    \bibitem{OVHPostgreSQL} 
    OVHcloud, "What is PostgreSQL?". Adres url: \url{https://www.ovhcloud.com/pl/learn/what-is-postgresql/}.

    \bibitem{PostgreSQL} 
    PostgreSQL Global Development Group. (n.d.). \textit{PostgreSQL: The world's most advanced open source database}. Adres url:  \url{https://www.postgresql.org/}

    \bibitem{EFPostgreSQL} 
    GeeksforGeeks. (2021, October 5). \textit{How to Access PostgreSQL Data Using Entity Framework}. Adres url:  \url{https://www.geeksforgeeks.org/how-to-access-postgresql-data-using-entity-framework/}

    \bibitem{PgAdmin} 
    pgAdmin Development Team. (n.d.). \textit{pgAdmin 4 Documentation}. Adres url:  \url{https://www.pgadmin.org/docs/pgadmin4/latest/}

    \bibitem{PgAdminFAQ} 
    pgAdmin, "FAQ". Adres url: \url{https://www.pgadmin.org/faq/}.

    \bibitem{ERDTool} 
    pgAdmin Development Team. (n.d.). \textit{ERD Tool — pgAdmin 4 8.14 documentation}. Adres url:  \url{https://www.pgadmin.org/docs/pgadmin4/latest/erd_tool.html}


    % silnik

    \bibitem{Stockfish}
    Stockfish. (n.d.). \textit{Stockfish - Open Source Chess Engine}. Adres url:  \url{https://stockfishchess.org/}
    
    \bibitem{StockfishUCI}
    Wikipedia. (2023, December 15). \textit{Stockfish (chess engine)}. Adres url:  \url{https://en.wikipedia.org/wiki/Stockfish_(chess_engine)}
    
    \bibitem{UCI}
    Wikipedia. (2023, December 12). \textit{Universal Chess Interface}. Adres url:  \url{https://en.wikipedia.org/wiki/Universal_Chess_Interface}
    
    \bibitem{Minimax}
    Wikipedia. (2023, November 21). \textit{Minimax}. Adres url:  \url{https://en.wikipedia.org/wiki/Minimax}

    % narzedzia
    \bibitem{GitWhatIs} 
    Microsoft, "What is Git?". Adres url: \url{https://learn.microsoft.com/pl-pl/devops/develop/git/what-is-git}.

    \bibitem{CodersLabGitHub} 
    Coders Lab, "GitHub – co to jest i do czego służy?". Adres url: \url{https://coderslab.pl/pl/blog/github-co-to-jest-i-do-czego-sluzy}.

    \bibitem{PolonTechSourceTree} 
    PolonTech, "SourceTree – jak korzystać z Git w GUI?". Adres url: \url{https://polontech.com/pl/sourcetree/}.

    \bibitem{BoringOwlFigma} 
    Boring Owl, "Figma". Adres url: \url{https://boringowl.io/tag/figma}.


    % dodatkowe

    \bibitem{WikiAndersHejlsberg} Wikipedia, "Anders Hejlsberg". Adres url: \url{https://pl.wikipedia.org/wiki/Anders_Hejlsberg}.


\end{thebibliography}
    
\end{document}
